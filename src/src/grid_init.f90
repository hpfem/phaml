!---------------------------------------------------------------------!
!                                PHAML                                !
!                                                                     !
! The Parallel Hierarchical Adaptive MultiLevel code for solving      !
! linear elliptic partial differential equations of the form          !
! (PUx)x + (QUy)y + RU = F on 2D polygonal domains with mixed         !
! boundary conditions, and eigenvalue problems where F is lambda*U.   !
!                                                                     !
! PHAML is public domain software.  It was produced as part of work   !
! done by the U.S. Government, and is not subject to copyright in     !
! the United States.                                                  !
!                                                                     !
!     William F. Mitchell                                             !
!     Mathematical and Computational Sciences Division                !
!     National Institute of Standards and Technology                  !
!     william.mitchell@nist.gov                                       !
!     http://math.nist.gov/phaml                                      !
!                                                                     !
!---------------------------------------------------------------------!

module grid_init_mod

!----------------------------------------------------
! This module contains routines to create, initialize and destroy the grid.
!
! communication tags in this module are of the form 31xx
!----------------------------------------------------

!----------------------------------------------------
! Other modules used:

use global
use gridtype_mod
use grid_util
use message_passing
use hash_mod
use sysdep
use sort_mod
!----------------------------------------------------

implicit none
private
public init_grid

!----------------------------------------------------
! Non-module procedures used are:

interface

   function trues(x,y,comp,eigen) ! real (my_real)
   use global
   real (my_real), intent(in) :: x,y
   integer, intent(in) :: comp, eigen
   real (my_real) :: trues
   end function trues

   subroutine bconds(x,y,bmark,itype,c,rs)
   use global
   real(my_real), intent(in) :: x,y
   integer, intent(in) :: bmark
   integer, intent(out) :: itype(:)
   real(my_real), intent(out) :: c(:,:),rs(:)
   end subroutine bconds

   subroutine boundary_point(ipiece,s,x,y)
   use global
   integer, intent(in) :: ipiece
   real(my_real), intent(in) :: s
   real(my_real), intent(out) :: x,y
   end subroutine boundary_point

   function boundary_npiece(hole)
   integer, intent(in) :: hole
   integer :: boundary_npiece
   end function boundary_npiece

end interface

!----------------------------------------------------
! The following defined constants are defined:

! RESTRICTION no more than 16 triangles share a vertex in the triangle data
integer, parameter :: MAX_TD_VERT_NEIGH = 16
!----------------------------------------------------
! The following variables are defined:

!----------------------------------------------------

contains

!          ---------
subroutine init_grid(grid,procs,degree,partition,set_iown)
!          ---------

!----------------------------------------------------
! This routine initializes the grid starting with the triangulation given by
! .node, .ele, .edge and .neigh files in the format generated by triangle.  The
! root name of the files is given in grid%triangle_files.  If the domain is
! given by boundary subroutines, it first creates the triangle data files.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

type(grid_type), intent(inout) :: grid
type(proc_info), intent(in) :: procs
integer, intent(in) :: degree,partition
logical, intent(in) :: set_iown

!----------------------------------------------------
! Local variables:

type(triangle_data) :: td
integer :: i, j, k, neigh, stat, nedge, edge, v1s, v2s, v1m, v2m, neighbmark, &
           igid
integer, allocatable :: mate(:)
integer :: elemedge_bmark(EDGES_PER_ELEMENT,size(grid%element))
integer :: bctype(grid%system_size)
real(my_real) :: bccoef(grid%system_size,grid%system_size), &
                 bcrhs(grid%system_size)
integer :: ni, nr
integer, pointer :: imess(:)
real(my_real), pointer :: rmess(:)

integer, parameter :: NO_MATE = BOUNDARY-1
!----------------------------------------------------
! Begin executable code

! create the triangle data files if the boundary is given by subroutines

if (boundary_npiece(0) > 0) then
   if (.false.) then
! TEMP this would cause multiple creations of the same file, in parallel
      call create_triangle_files(grid)
   else
! TEMP this requires all processes share the same file system
      if (my_proc(procs) == MASTER .or. PARALLEL==SEQUENTIAL) then
         call create_triangle_files(grid)
         do i=1,num_proc(procs)
            call phaml_send(procs,i,(/0/),0,(/0.0_my_real/),0,3101)
         end do
      else
         call phaml_recv(procs,j,imess,ni,rmess,nr,3101)
      endif
   endif
endif

! get the starting grid from the data files

call read_triangle_data(grid,td)

! included master for creating triangle data files and checking on opening
! triangle data files, but don't generate a grid for the master

if (my_proc(procs) == MASTER) then
   return
endif

! space for PERIODIC_MASTER vertex for PERIODIC_SLAVEs

allocate(td%vert_master(td%nvert),stat=stat)
if (stat /= 0) then
   call fatal("allocation failed for mates in init_grid")
   stop
endif

td%vert_master = NO_MATE

! match up sides with periodic boundary conditions

call match_periodic(grid,td,NO_MATE)

! pair up most triangles

allocate(mate(td%ntri),stat=stat)
if (stat /= 0) then
   call fatal("allocation failed for mates in init_grid")
   stop
endif

mate = NO_MATE
call pair_triangles(td,mate,NO_MATE)

! Refine the starting grid by bisecting paired triangles and trisecting others.
! This defines these components of grid: vertex%coord, element%gid, &
! element%mate, element%vertex, nelem, nvert, initial_neighbor
! It also sets vertex%assoc_elem to be the master vertex for vertices that
! are PERIODIC_SLAVE (negative bmark) or endpoints of a PERIODIC SLAVE side,
! and NO_MATE for all other vertices. This is just a convenient component to
! use for temporary storage.

call refine_start(grid,td,mate,elemedge_bmark,NO_MATE)

! Set the vertex linked list.  Need to do vertices on sides that have
! periodic boundary conditions first so that
! next(PERIODIC_SLAVE) = PERIODIC_MASTER.  And need to have nonpeaks before
! peaks so that ancestors of level 2 equations come before parents in the
! numbering of equations (see make_linear_system).  Since the linked list is
! built from the tail to the head, the order of building it is
!   peak, periodic
!   peak, nonperiodic
!   nonpeak, periodic
!   nonpeak, nonperiodic
! assoc_elem was used as a place to store the master associated with a slave.
! Also set vertex type to a form of PERIODIC or INTERIOR as an initialization.

grid%head_level_vert(1) = END_OF_LIST
do i=td%nvert+1,grid%nvert
   if (grid%vertex(i)%assoc_elem /= NO_MATE .and. &
       grid%vertex(i)%assoc_elem /= NO_MATE-1) then
      grid%vertex(grid%vertex(i)%assoc_elem)%next = grid%head_level_vert(1)
      grid%vertex(i)%next = grid%vertex(i)%assoc_elem
      grid%head_level_vert(1) = i
      grid%vertex_type(i,:) = PERIODIC_SLAVE
      grid%vertex_type(grid%vertex(i)%assoc_elem,:) = PERIODIC_MASTER
      grid%vertex(grid%vertex(i)%assoc_elem)%assoc_elem = NO_MATE-1
   endif
end do

do i=td%nvert+1,grid%nvert
   if (grid%vertex(i)%assoc_elem == NO_MATE) then
      grid%vertex(i)%next = grid%head_level_vert(1)
      grid%head_level_vert(1) = i
      grid%vertex_type(i,:) = INTERIOR
   endif
end do

do i=1,td%nvert
   if (grid%vertex(i)%assoc_elem /= NO_MATE .and. &
       grid%vertex(i)%assoc_elem /= NO_MATE-1) then
      grid%vertex(grid%vertex(i)%assoc_elem)%next = grid%head_level_vert(1)
      grid%vertex(i)%next = grid%vertex(i)%assoc_elem
      grid%head_level_vert(1) = i
      grid%vertex_type(i,:) = PERIODIC_SLAVE
      grid%vertex_type(grid%vertex(i)%assoc_elem,:) = PERIODIC_MASTER
      grid%vertex(grid%vertex(i)%assoc_elem)%assoc_elem = NO_MATE-1
   endif
end do

do i=1,td%nvert
   if (grid%vertex(i)%assoc_elem == NO_MATE) then
      grid%vertex(i)%next = grid%head_level_vert(1)
      grid%head_level_vert(1) = i
      grid%vertex_type(i,:) = INTERIOR
   endif
end do

i = grid%head_level_vert(1)
grid%vertex(i)%previous = END_OF_LIST
do while (i /= END_OF_LIST)
   j = grid%vertex(i)%next
   if (j /= END_OF_LIST) grid%vertex(j)%previous = i
   i = j
end do

! set remaining components of grid
! also set vertex 1 to be the smaller of vertex 1 and vertex 2 so that
! pairs agree

! define the elements

grid%head_level_elem(1) = 1
do i=1,grid%nelem
   if (grid%element(i)%vertex(1) > grid%element(i)%vertex(2)) then
      j = grid%element(i)%vertex(1)
      grid%element(i)%vertex(1) = grid%element(i)%vertex(2)
      grid%element(i)%vertex(2) = j
      j = grid%initial_neighbor(1,i)
      grid%initial_neighbor(1,i) = grid%initial_neighbor(2,i)
      grid%initial_neighbor(2,i) = j
      j = elemedge_bmark(1,i)
      elemedge_bmark(1,i) = elemedge_bmark(2,i)
      elemedge_bmark(2,i) = j
   endif
   grid%element(i)%degree = degree
   if (degree > 2) then
      allocate(grid%element(i)%solution(((degree-1)*(degree-2))/2,grid%system_size,max(1,grid%num_eval)),&
               stat=stat)
      if (stat /= 0) then
         call fatal("allocation failed for mates in init_grid")
         stop
      endif
      grid%element(i)%solution = 0.0_my_real
      if (grid%have_true) then
         allocate(grid%element(i)%exact(((degree-1)*(degree-2))/2,grid%system_size,max(1,grid%num_eval)),&
                  stat=stat)
         if (stat /= 0) then
            call fatal("allocation failed for mates in init_grid")
            stop
         endif
         grid%element(i)%exact = 0.0_my_real
      endif
   endif
   grid%element(i)%in = grid%element(i)%vertex(1)
   grid%element(i)%out = grid%element(i)%vertex(2)
   grid%element(i)%order = (/1,2/)
   grid%element(i)%level = 1
   grid%element(i)%next = i+1
   grid%element(i)%iown = set_iown
   grid%element(i)%hrefined_unowned = .false.
   grid%element(i)%prefined_unowned = .false.
   grid%element(i)%isleaf = .true.
   grid%element(i)%oldleaf = .false.
   grid%element(i)%sp_eta_pred = 0.0_my_real
   call hash_insert(grid%element(i)%gid,i,grid%elem_hash)
   do j=1,3
      grid%vertex(grid%element(i)%vertex(j))%assoc_elem = i
      if (grid%initial_neighbor(j,i) == BOUNDARY) then
         where (grid%vertex_type(grid%element(i)%vertex(1+mod(j,3)),:) == INTERIOR) &
            grid%vertex_type(grid%element(i)%vertex(1+mod(j,3)),:) = DIRICHLET
         where (grid%vertex_type(grid%element(i)%vertex(1+mod(j+1,3)),:) == INTERIOR) &
            grid%vertex_type(grid%element(i)%vertex(1+mod(j+1,3)),:) = DIRICHLET
      endif
   end do
end do
grid%element(grid%nelem)%next = END_OF_LIST

grid%next_free_elem = grid%nelem+1
grid%nelem_leaf = grid%nelem
if (set_iown) then
   grid%nelem_leaf_own = grid%nelem
else
   grid%nelem_leaf_own = 0
endif

! define the vertices

grid%boundbox_min = point(huge(0.0_my_real),huge(0.0_my_real))
grid%boundbox_max = point(-huge(0.0_my_real),-huge(0.0_my_real))
do i=1,grid%nvert
   grid%vertex(i)%gid = i
   if (grid%vertex_type(i,1) == INTERIOR) then
      grid%vertex_solution(i,:,:) = 0.0_my_real
   else
      call bconds(grid%vertex(i)%coord%x,grid%vertex(i)%coord%y, &
                  grid%vertex(i)%bmark,bctype,bccoef,bcrhs)
      do j=1,grid%system_size
         if (grid%vertex_type(i,j) == PERIODIC_SLAVE .or. &
             grid%vertex_type(i,j) == PERIODIC_MASTER) then
            select case(bctype(j))
            case (DIRICHLET)
               if (grid%vertex_type(i,j) == PERIODIC_SLAVE) then
                  grid%vertex_type(i,j) = PERIODIC_SLAVE_DIR
               else
                  grid%vertex_type(i,j) = PERIODIC_MASTER_DIR
               endif
            case (NATURAL)
               if (grid%vertex_type(i,j) == PERIODIC_SLAVE) then
                  grid%vertex_type(i,j) = PERIODIC_SLAVE_NAT
               else
                  grid%vertex_type(i,j) = PERIODIC_MASTER_NAT
               endif
            case (MIXED)
               if (grid%vertex_type(i,j) == PERIODIC_SLAVE) then
                  grid%vertex_type(i,j) = PERIODIC_SLAVE_MIX
               else
                  grid%vertex_type(i,j) = PERIODIC_MASTER_MIX
               endif
            case (PERIODIC)
               if (grid%vertex(i)%bmark < 0) then
                  grid%vertex_type(i,j) = PERIODIC_SLAVE
               else
                  grid%vertex_type(i,j) = PERIODIC_MASTER
               endif
            end select
         else
            grid%vertex_type(i,j) = bctype(j)
         endif
         if (grid%vertex_type(i,j) == DIRICHLET .or. &
             grid%vertex_type(i,j) == PERIODIC_SLAVE_DIR .or. &
             grid%vertex_type(i,j) == PERIODIC_MASTER_DIR) then
            grid%vertex_solution(i,j,:) = bcrhs(j)
         else
            grid%vertex_solution(i,j,:) = 0.0_my_real
         endif
      end do
   endif
   call hash_insert(grid%vertex(i)%gid,i,grid%vert_hash)
   if (grid%vertex(i)%coord%x < grid%boundbox_min%x) then
      grid%boundbox_min%x = grid%vertex(i)%coord%x
   endif
   if (grid%vertex(i)%coord%x > grid%boundbox_max%x) then
      grid%boundbox_max%x = grid%vertex(i)%coord%x
   endif
   if (grid%vertex(i)%coord%y < grid%boundbox_min%y) then
      grid%boundbox_min%y = grid%vertex(i)%coord%y
   endif
   if (grid%vertex(i)%coord%y > grid%boundbox_max%y) then
      grid%boundbox_max%y = grid%vertex(i)%coord%y
   endif
end do
grid%next_free_vert = grid%nvert+1
if (set_iown) then
   grid%nvert_own = grid%nvert
else
   grid%nvert_own = 0
endif

! check for true solution known

if (trues((grid%boundbox_max%x+grid%boundbox_min%x)/2, &
          (grid%boundbox_max%y+grid%boundbox_min%y)/2, 1, 1) &
    == huge(0.0_my_real)) then
   grid%have_true = .false.
else
   grid%have_true = .true.
   allocate(grid%vertex_exact(size(grid%vertex),grid%system_size,max(1,grid%num_eval)), &
            stat=stat)
   if (stat /= 0) then
      call fatal("allocation failed for vertex_exact in init_grid")
      stop
   endif
endif

! define the edges

nedge = 0
do i=1,grid%nelem
   do j=1,EDGES_PER_ELEMENT
      neigh = grid%initial_neighbor(j,i)
      neighbmark = 1
      if (neigh /= BOUNDARY) then
         do k=1,EDGES_PER_ELEMENT
            if (grid%initial_neighbor(k,neigh) == i) then
               neighbmark = elemedge_bmark(k,neigh)
            endif
         end do
      endif
      if (neigh == BOUNDARY .or. neigh > i .or. elemedge_bmark(j,i) < 0 .or. &
          neighbmark < 0) then
         nedge = nedge + 1
         grid%element(i)%edge(j) = nedge
         grid%edge(nedge)%vertex(1) = &
            grid%element(i)%vertex(1+mod(j,EDGES_PER_ELEMENT))
         grid%edge(nedge)%vertex(2) = &
            grid%element(i)%vertex(1+mod(j+1,EDGES_PER_ELEMENT))
         if (grid%vertex(grid%edge(nedge)%vertex(2))%gid < &
             grid%vertex(grid%edge(nedge)%vertex(1))%gid) then
            k = grid%edge(nedge)%vertex(1)
            grid%edge(nedge)%vertex(1) = grid%edge(nedge)%vertex(2)
            grid%edge(nedge)%vertex(2) = k
         endif
         grid%edge(nedge)%bmark = elemedge_bmark(j,i)
         if (neigh == BOUNDARY .or. elemedge_bmark(j,i) < 0 .or. &
             neighbmark < 0) then
! point is not on curved boundary, but I'm only after bctype
            call bconds((grid%vertex(grid%edge(nedge)%vertex(1))%coord%x + &
                         grid%vertex(grid%edge(nedge)%vertex(2))%coord%x)/2, &
                        (grid%vertex(grid%edge(nedge)%vertex(1))%coord%y + &
                         grid%vertex(grid%edge(nedge)%vertex(2))%coord%y)/2, &
                        grid%edge(nedge)%bmark,bctype,bccoef,bcrhs)
            grid%edge_type(nedge,:) = bctype
            do k=1,grid%system_size
               if (grid%edge_type(nedge,k) == PERIODIC) then
                  if (grid%edge(nedge)%bmark < 0) then
                     grid%edge_type(nedge,k) = PERIODIC_SLAVE
                  else
                     grid%edge_type(nedge,k) = PERIODIC_MASTER
                  endif
               endif
            end do
         else
            grid%edge_type(nedge,:) = INTERIOR
         endif
         grid%edge(nedge)%assoc_elem = i
         grid%edge(nedge)%degree = degree
         if (degree > 1) then
            allocate(grid%edge(nedge)%solution(degree-1,grid%system_size,max(1,grid%num_eval)),&
                     stat=stat)
            if (stat /= 0) then
               call fatal("allocation failed for mates in init_grid")
               stop
            endif
            if (grid%have_true) then
               allocate(grid%edge(nedge)%exact(degree-1,grid%system_size,max(1,grid%num_eval)),&
                        stat=stat)
               if (stat /= 0) then
                  call fatal("allocation failed for mates in init_grid")
                  stop
               endif
               grid%edge(nedge)%exact = 0.0_my_real
            endif
            do k=1,grid%system_size
               if (grid%edge_type(nedge,k) == DIRICHLET) then
                  call edge_exact(grid,nedge,k,"d")
               else
                  grid%edge(nedge)%solution(:,k,:) = 0.0_my_real
               endif
            end do
         endif
      else
         do k=1,EDGES_PER_ELEMENT
            if (grid%initial_neighbor(k,neigh) == i) then
               grid%element(i)%edge(j) = grid%element(neigh)%edge(k)
               exit
            endif
         end do
      endif
   end do
end do

! Initial edge gids start at ceiling(nedge/3)
igid = nedge/3
if (3*igid /= nedge) igid= igid+1
do i=1,nedge
   grid%edge(i)%gid = igid + i-1
   call hash_insert(grid%edge(i)%gid,i,grid%edge_hash)
end do
grid%next_free_edge = nedge+1

grid%nedge = nedge
if (set_iown) then
   grid%nedge_own = grid%nedge
else
   grid%nedge_own = 0
endif
grid%dof = grid%nvert*grid%system_size
if (degree >= 2) grid%dof = grid%dof + nedge*(degree-1)*grid%system_size
if (degree >= 3) grid%dof = grid%dof + &
                    grid%nelem*(((degree-2)*(degree-1))/2)*grid%system_size
grid%dof_own = grid%dof

! find the master edge for PERIODIC_SLAVE edges

do i=1,grid%nelem
   do j=1,EDGES_PER_ELEMENT
      edge = grid%element(i)%edge(j)
      if (any(grid%edge_type(edge,:) == PERIODIC_SLAVE)) then
         neigh = grid%initial_neighbor(j,i)
         v1s = grid%edge(edge)%vertex(1)
         v2s = grid%edge(edge)%vertex(2)
         do k=1,EDGES_PER_ELEMENT
            v1m = grid%edge(grid%element(neigh)%edge(k))%vertex(1)
            v2m = grid%edge(grid%element(neigh)%edge(k))%vertex(2)
            if ((v1m == grid%vertex(v1s)%next .and. v2m == grid%vertex(v2s)%next) .or. &
                (v2m == grid%vertex(v1s)%next .and. v1m == grid%vertex(v2s)%next)) then
               grid%edge(edge)%next = grid%element(neigh)%edge(k)
               exit
            endif
         end do
      endif
   end do
end do

grid%partition = partition
grid%nlev = 1
grid%errind_up2date = .false.

! smooth the triangle shapes

! TEMP071217 optional no smoothing; for the battery example

if (.not. dont_smooth) then
   call smooth_grid(grid,procs)
endif

! compute exact after smoothing, because vertices moved

if (grid%have_true) then
   do i=1,grid%nvert
      do k=1,max(1,grid%num_eval)
         do j=1,grid%system_size
            grid%vertex_exact(i,j,k) = trues(grid%vertex(i)%coord%x, &
                                             grid%vertex(i)%coord%y, &
                                             j,k)
         end do
      end do
   end do
endif

if (grid%have_true) then
   do i=1,grid%nelem
      do k=1,grid%system_size
         do j=1,EDGES_PER_ELEMENT
            if (grid%initial_neighbor(j,i) > i) cycle
            call edge_exact(grid,grid%element(i)%edge(j),k,"t")
         end do
         call elem_exact(grid,i,k,"t")
      end do
   end do
endif

! set the path through the initial grid for RTK.  If using Zoltan, Zoltan will
! reset it.

call init_path(grid)

deallocate(td%vert_coord,td%tri_edge,td%tri_vert,td%tri_neigh,td%edge_tri, &
           td%edge_vert,td%vert_tri,td%vert_edge,td%vert_bmark, &
           td%vert_bparam,td%edge_bmark,td%vert_master,stat=stat)

end subroutine init_grid

!          ---------------------
subroutine create_triangle_files(grid)
!          ---------------------

!----------------------------------------------------
! This routine creates the triangle data files for the domain given by the
! domain boundary subroutines.
! grid%max_blen is the maximum length of the line between adjacent boundary
! vertices.
! grid%triangle_files is the root of the created triangle data files.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

type(grid_type), intent(in) :: grid
!----------------------------------------------------
! Local variables:

logical :: exists, opened
logical, allocatable :: singleton(:)
character(len=20) :: carea
integer :: total_npiece, k, astat, iounit, nhole, nvert, hole, vert, &
           edge, piece, first_vert
integer, allocatable :: npiece(:), end_hole(:), last_vert(:)
real(my_real) :: area, x1, y1, x2, y2
real(my_real), allocatable :: mid(:)
!----------------------------------------------------
! Begin executable code

! count the number of holes

nhole = 1
do while (boundary_npiece(nhole) > 0)
   nhole = nhole + 1
end do
nhole = nhole - 1
allocate(npiece(0:nhole),end_hole(-1:nhole),stat=astat)
if (astat /= 0) then
   ierr = ALLOC_FAILED
   call fatal("memory allocation failed in create_triangle_files")
   stop
endif

! get number of boundary pieces, the piece that ends each hole, and
! parameter limits

total_npiece = 0
end_hole(-1) = 0
do hole=0,nhole
   npiece(hole) = boundary_npiece(hole)
   total_npiece = total_npiece + npiece(hole)
   end_hole(hole) = end_hole(hole-1) + npiece(hole)
end do
allocate(mid(total_npiece),last_vert(total_npiece),singleton(0:total_npiece), &
         stat=astat)
if (astat /= 0) then
   ierr = ALLOC_FAILED
   call fatal("memory allocation failed in create_triangle_files")
   stop
endif
mid = (grid%bp_start+grid%bp_finish)/2

! find an available unit and open file for writing

iounit = 11
do
   inquire(unit=iounit,exist=exists,opened=opened)
   if (exists .and. .not. opened) exit
   iounit = iounit + 1
end do
open(unit=iounit,file=trim(grid%triangle_files)//".poly",status="replace")

! count the number of vertices and edges that will be written, and identify
! boundary pieces that are just a single vertex

nvert = 0
singleton(0) = .false.
do piece=1,total_npiece
   singleton(piece) = grid%bp_start(piece)==grid%bp_finish(piece)
   call create_triangle_files_recur(piece,grid%bp_start(piece),mid(piece), &
                                    grid%max_blen,nvert,.not.singleton(piece-1))
   if (.not. singleton(piece)) then
      call create_triangle_files_recur(piece,mid(piece),grid%bp_finish(piece), &
                                       grid%max_blen,nvert,.true.)
   endif
end do

! write the vertex count line

write(iounit,"(I12,3I2)") nvert,2,0,1

! make sure the end of each piece is the beginning of the next, and that
! no part has a singleton at the end

do hole=0,nhole
   do piece=end_hole(hole-1)+1,end_hole(hole)
      if (piece == end_hole(hole)) then
         k = end_hole(hole-1) + 1
      else
         k = piece+1
      endif
      call boundary_point(piece,grid%bp_finish(piece),x1,y1)
      call boundary_point(k,grid%bp_start(k),x2,y2)
      if (sqrt((x1-x2)**2 + (y1-y2)**2) > 10000*epsilon(1.0_my_real)) then
         ierr = USER_INPUT_ERROR
         call fatal("End of boundary piece does not match beginning of next piece.", &
                    reallist=(/x1,y1,x2,y2/),intlist=(/piece,k/))
         stop
      endif
   end do
   if (singleton(end_hole(hole))) then
      ierr = USER_INPUT_ERROR
      call fatal("Final boundary piece of outer boundary or any hole cannot be a single point.", &
                 "Make that point be the first piece, instead.")
      stop
   endif
end do

! write the vertices
! when a piece is a singleton, don't do the second half and don't do the
! first point of the next piece

nvert = 0
do piece=1,total_npiece
   call create_triangle_files_recur(piece,grid%bp_start(piece),mid(piece), &
                                    grid%max_blen,nvert, &
                                    .not.singleton(piece-1),iounit)
   if (.not. singleton(piece)) then
      call create_triangle_files_recur(piece,mid(piece),grid%bp_finish(piece), &
                                       grid%max_blen,nvert,.true.,iounit)
   endif
   last_vert(piece) = nvert
end do

! write the edge count line

write(iounit,"(I12,I2)") nvert,1

! write the edges

hole = 0
first_vert = 1
piece = 1
do while(singleton(piece))
   piece = piece+1
end do
do vert=1,nvert
   edge = vert
   if (vert == last_vert(piece)) then
      if (piece == end_hole(hole)) then
         write(iounit,"(4I12)") edge,vert,first_vert,piece
         hole = hole+1
         first_vert = vert+1
      else
         write(iounit,"(4I12)") edge,vert,vert+1,piece
      endif
      piece = piece+1
      if (piece > total_npiece) exit
      do while(singleton(piece))
         piece = piece+1
      end do
   else
      write(iounit,"(4I12)") edge,vert,vert+1,piece
   endif
end do

! write the hole count line

write(iounit,"(I12)") nhole

! for each hole compute a point inside the hole as the average of the
! piece endpoints and midpoints.  this can fail if the hole is too concave.

do hole=1,nhole
   x2 = 0.0_my_real
   y2 = 0.0_my_real
   k = 0
   do piece=end_hole(hole-1)+1,end_hole(hole)
      call boundary_point(piece,grid%bp_start(piece),x1,y1)
      x2 = x2 + x1
      y2 = y2 + y1
      call boundary_point(piece,(grid%bp_start(piece)+grid%bp_finish(piece))/2,&
                          x1,y1)
      x2 = x2 + x1
      y2 = y2 + y1
      k = k+2
   end do
   x2 = x2/k
   y2 = y2/k
   write(iounit,"(I12,SS,1P,2E21.13E2)") hole,x2,y2
end do

close(iounit)

deallocate(mid,last_vert,singleton,npiece,end_hole,stat=astat)

! run Triangle to create the other triangle data files

if (grid%max_blen == huge(0.0_my_real)) then
   call my_system("triangle -pneqjQIY "//trim(grid%triangle_files)//".poly")
else
   area = grid%max_blen**2*sqrt(3.0_my_real)/4
   write(carea,"(f20.10)") area
   k = index(carea," ",back=.true.)
   call my_system("triangle -pneq28 -jQI -a"//carea(k+1:)//" "//trim(grid%triangle_files)//".poly")
endif

end subroutine create_triangle_files

!          ------
recursive subroutine create_triangle_files_recur(ipiece,s1,s2,max_blen,count, &
                                                inc_start,iounit)
!          ------

!----------------------------------------------------
! This routine increments count by the number of vertices and edges needed
! for boundary piece i between parameters s1 and s2 with maximum segment
! length max_blen, and optionally write the vertices to unit iounit if present.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

integer, intent(in) :: ipiece
real(my_real), intent(in) :: s1, s2, max_blen
integer, intent(inout) :: count
logical, intent(in) :: inc_start
integer, intent(in), optional :: iounit
!----------------------------------------------------
! Local variables:

real(my_real) :: x1, x2, y1, y2, sm
!----------------------------------------------------
! Begin executable code

! get the coordinates of the endpoints

call boundary_point(ipiece,s1,x1,y1)
call boundary_point(ipiece,s2,x2,y2)

if (sqrt((x2-x1)**2 + (y2-y1)**2) > max_blen) then

! if this segment is too long, bisect it

   sm = (s1+s2)/2
   call create_triangle_files_recur(ipiece,s1,sm,max_blen,count,inc_start,iounit)
   call create_triangle_files_recur(ipiece,sm,s2,max_blen,count,.true.,iounit)

! if it is short enough, increment the count and write the starting endpoint

else

   if (inc_start) then
      count = count+1
      if (present(iounit)) write(iounit,"(I12,SS,1P,2E21.13E2,I12)") count,x1,y1,ipiece
   endif

endif

end subroutine create_triangle_files_recur

!          ------------------
subroutine read_triangle_data(grid,td)
!          ------------------

!----------------------------------------------------
! This routine reads data from .node, .ele, .edge and .neigh files in the format
! of Jonathan Richard Shewchuk's mesh generation program "triangle".
!
! NOTE: I assume there are no comment lines before the end of the data.
!       Triangle 1.5 seems to obey this.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

type(grid_type), intent(in) :: grid
type(triangle_data), intent(out) :: td
!----------------------------------------------------
! Local variables:

integer :: i, j, k, stat, td_dim, td_natt, td_nbm, bmark, vert, td_npt, tri, &
           v1, v2, v3, td_ntri2, td_nneigh, edge, end1, end2, iounit, nset
logical, allocatable :: used(:)
real(my_real) :: x, y
logical :: exists, opened
!----------------------------------------------------
! Begin executable code

! find an available i/o unit number

iounit = 11
do
   inquire(unit=iounit,exist=exists,opened=opened)
   if (exists .and. .not. opened) exit
   iounit = iounit + 1
end do

! read the node (vertex) data from the triangle data file

open(unit=iounit,file=trim(grid%triangle_files)//".node",status="old", &
     action="read",iostat=stat)
if (stat /= 0) then
   call fatal("open failed for file "//trim(grid%triangle_files)//".node", &
              "iostat is ",intlist=(/stat/))
   stop
endif

read(iounit,*) td%nvert, td_dim, td_natt, td_nbm
if (td_natt /= 0) then
   call fatal("number of attributes in .node file must be 0")
   stop
endif
allocate(used(td%nvert),stat=stat)
if (stat /= 0) then
   call fatal("memory allocation for vertices from .node file failed", &
              intlist=(/stat,td%nvert/))
   stop
endif

allocate(td%vert_tri(MAX_TD_VERT_NEIGH,td%nvert), &
         td%vert_edge(MAX_TD_VERT_NEIGH,td%nvert), &
         td%vert_bmark(td%nvert), td%vert_bparam(td%nvert), &
         td%vert_coord(td%nvert), &
         stat=stat)
if (stat /= 0) then
   call fatal("memory allocation for vertices from .node file failed", &
              intlist=(/stat,td%nvert/))
   stop
endif

if (td_nbm == 0) then
   call fatal("boundary markers are required in data from Triangle")
   stop
endif

do i=1,td%nvert
   read(iounit,*) vert,x,y,bmark
   if (vert < 1) then
      call fatal("vertices in .node file must be numbered starting at 1")
      stop
   endif
   if (vert > td%nvert) then
      call fatal("vertex number in .node file is larger than stated number of vertices", &
                 intlist=(/vert,td%nvert/))
      stop
   endif
   td%vert_coord(vert)%x = x
   td%vert_coord(vert)%y = y
   td%vert_bmark(vert) = bmark
   td%vert_bparam(vert) = find_point_bparam(bmark,x,y,grid)
end do

close(unit=iounit)

! read the element data from the .ele file

open(unit=iounit,file=trim(grid%triangle_files)//".ele",status="old", &
     action="read",iostat=stat)
if (stat /= 0) then
   call fatal("open failed for file "//trim(grid%triangle_files)//".ele", &
              "iostat is ",intlist=(/stat/))
   stop
endif

read(iounit,*) td%ntri, td_npt, td_natt
allocate(td%tri_edge(EDGES_PER_ELEMENT,td%ntri), &
         td%tri_vert(VERTICES_PER_ELEMENT,td%ntri), &
         stat=stat)
if (stat /= 0) then
   call fatal("memory allocation for triangles from .ele file failed", &
              intlist=(/stat,td%ntri/))
   stop
endif

used = .false.
do i=1,td%ntri
   read(iounit,*) tri,v1,v2,v3
   if (tri < 1) then
      call fatal("triangles in .ele file must be numbered starting at 1")
      stop
   endif
   if (tri > td%ntri) then
      call fatal("triangle number in .ele file is larger than stated number of triangles", &
                 intlist=(/tri,td%ntri/))
      stop
   endif
   td%tri_vert(1,tri) = v1
   td%tri_vert(2,tri) = v2
   td%tri_vert(3,tri) = v3
   used(v1) = .true.
   used(v2) = .true.
   used(v3) = .true.
end do

close(unit=iounit)

if (.not. all(used)) then
   ierr = USER_INPUT_ERROR
   call fatal("There are unused nodes in the .node file.", &
              "Use the -j flag when running triangle.")
   stop
endif

deallocate(used)

! read the neighbor data from the .neigh file

open(unit=iounit,file=trim(grid%triangle_files)//".neigh",status="old", &
     action="read",iostat=stat)
if (stat /= 0) then
   call fatal("open failed for file "//trim(grid%triangle_files)//".neigh", &
              "iostat is ",intlist=(/stat/))
   stop
endif

read(iounit,*) td_ntri2, td_nneigh
if (td_ntri2 /= td%ntri) then
   call fatal("number of triangles in .neigh file is not the same as number in .ele file", &
              intlist=(/td_ntri2,td%ntri/))
   stop
endif
allocate(td%tri_neigh(3,td%ntri),stat=stat)
if (stat /= 0) then
   call fatal("memory allocation for neighbors from .neigh file failed", &
              intlist=(/stat,td%ntri/))
   stop
endif

do i=1,td%ntri
   read(iounit,*) tri,v1,v2,v3
   if (tri < 1) then
      call fatal("triangles in .neigh file must be numbered starting at 1")
      stop
   endif
   if (tri > td%ntri) then
      call fatal("triangle number in .neigh file is larger than stated number of triangles", &
                 intlist=(/tri,td%ntri/))
      stop
   endif
   td%tri_neigh(1,tri) = v1
   td%tri_neigh(2,tri) = v2
   td%tri_neigh(3,tri) = v3
end do

close(unit=iounit)

! read the edge data from the triangle edge file

open(unit=iounit,file=trim(grid%triangle_files)//".edge",status="old", &
     action="read",iostat=stat)
if (stat /= 0) then
   call fatal("open failed for file "//trim(grid%triangle_files)//".edge", &
              "iostat is ",intlist=(/stat/))
   stop
endif

read(iounit,*) td%nedge, td_nbm
allocate(td%edge_tri(2,td%nedge), td%edge_vert(2,td%nedge), &
         td%edge_bmark(td%nedge), stat=stat)
if (stat /= 0) then
   call fatal("memory allocation for vertices from .edge file failed", &
              intlist=(/stat,td%nedge/))
   stop
endif

if (td_nbm == 0) then
   call fatal("boundary markers are required in data from Triangle")
   stop
endif

do i=1,td%nedge
   read(iounit,*) edge,end1,end2,bmark
   if (edge < 1) then
      call fatal("edges in .edge file must be numbered starting at 1")
      stop
   endif
   if (edge > td%nedge) then
      call fatal("edge number in .edge file is larger than stated number of edges", &
                 intlist=(/edge,td%nedge/))
      stop
   endif
   td%edge_vert(1,edge) = end1
   td%edge_vert(2,edge) = end2
   td%edge_bmark(edge) = bmark
end do

close(unit=iounit)

! NEW
! derive other components of triangle data

! set the triangle list for each vertex

td%vert_tri = -1
do i=1,td%ntri
   do j=1,3
      do k=1,MAX_TD_VERT_NEIGH
         if (td%vert_tri(k,td%tri_vert(j,i)) == -1) exit
      end do
      if (k == MAX_TD_VERT_NEIGH+1) then
         call fatal("too many neighbors of a vertex in triangle data")
         stop
      endif
      td%vert_tri(k,td%tri_vert(j,i)) = i
   end do
end do

! set the edge list for each vertex

td%vert_edge = -1
do i=1,td%nedge
   do j=1,2
      do k=1,MAX_TD_VERT_NEIGH
         if (td%vert_edge(k,td%edge_vert(j,i)) == -1) exit
      end do
      if (k == MAX_TD_VERT_NEIGH+1) then
         call fatal("too many neighbors of a vertex in triangle data")
         stop
      endif
      td%vert_edge(k,td%edge_vert(j,i)) = i
   end do
end do

! set the edge list of each triangle, and triangle list of each edge

td%tri_edge = -1
td%edge_tri = -1

! for each triangle
do i=1,td%ntri
   nset = 0
! for each vertex of the triangle
   do j=1,3
! search the edges of the vertex for any that contain another vertex of the
! triangle
! for each edge of this vertex
      do k=1,MAX_TD_VERT_NEIGH
         if (td%vert_edge(k,td%tri_vert(j,i)) == -1) exit
! if the first vertex of the edge is this vertex, see if the second vertex of
! the edge is a vertex of the triangle
         if (td%edge_vert(1,td%vert_edge(k,td%tri_vert(j,i))) == td%tri_vert(j,i)) then
            if (td%edge_vert(2,td%vert_edge(k,td%tri_vert(j,i))) == &
                td%tri_vert(1,i) .or. &
                td%edge_vert(2,td%vert_edge(k,td%tri_vert(j,i))) == &
                td%tri_vert(2,i) .or. &
                td%edge_vert(2,td%vert_edge(k,td%tri_vert(j,i))) == &
                td%tri_vert(3,i)) then
! if so make it an edge of this triangle, and make this triangle a triangle
! of that edge, unless it has already been set
               if (td%edge_tri(1,td%vert_edge(k,td%tri_vert(j,i))) /= i .and. &
                   td%edge_tri(2,td%vert_edge(k,td%tri_vert(j,i))) /= i) then
                  nset = nset + 1
                  td%tri_edge(nset,i) = td%vert_edge(k,td%tri_vert(j,i))
                  if (td%edge_tri(1,td%vert_edge(k,td%tri_vert(j,i))) == -1) then
                     td%edge_tri(1,td%vert_edge(k,td%tri_vert(j,i))) = i
                  elseif (td%edge_tri(2,td%vert_edge(k,td%tri_vert(j,i))) == -1) then
                     td%edge_tri(2,td%vert_edge(k,td%tri_vert(j,i))) = i
                  else
                     call fatal("too many triangles neighboring an edge in read_trianlge_data")
                     stop
                  endif
               endif
            endif
! if the second vertex of the edge is this vertex, see if the first vertex of
! the edge is a vertex of the triangle
         elseif (td%edge_vert(2,td%vert_edge(k,td%tri_vert(j,i))) == td%tri_vert(j,i)) then
            if (td%edge_vert(1,td%vert_edge(k,td%tri_vert(j,i))) == &
                td%tri_vert(1,i) .or. &
                td%edge_vert(1,td%vert_edge(k,td%tri_vert(j,i))) == &
                td%tri_vert(2,i) .or. &
                td%edge_vert(1,td%vert_edge(k,td%tri_vert(j,i))) == &
                td%tri_vert(3,i)) then
! if so make it an edge of this triangle, and make this triangle a triangle
! of that edge, unless it has already been set
               if (td%edge_tri(1,td%vert_edge(k,td%tri_vert(j,i))) /= i .and. &
                   td%edge_tri(2,td%vert_edge(k,td%tri_vert(j,i))) /= i) then
                  nset = nset + 1
                  td%tri_edge(nset,i) = td%vert_edge(k,td%tri_vert(j,i))
                  if (td%edge_tri(1,td%vert_edge(k,td%tri_vert(j,i))) == -1) then
                     td%edge_tri(1,td%vert_edge(k,td%tri_vert(j,i))) = i
                  elseif (td%edge_tri(2,td%vert_edge(k,td%tri_vert(j,i))) == -1) then
                     td%edge_tri(2,td%vert_edge(k,td%tri_vert(j,i))) = i
                  else
                     call fatal("too many triangles neighboring an edge in read_trianlge_data")
                     stop
                  endif
               endif
            endif
         endif
      end do
   end do
end do

! verify that all triangles have 3 edges and all edges have 2 triangles or
! are boundary

do i=1,td%ntri
   if (td%tri_edge(3,i) == -1) then
      call fatal("didn't assign 3 edges to all triangles in read_triangle_data")
      stop
   endif
end do
! TEMP must verify that bmark/=0 iff vertex is on boundary.  Might need to
! change the documentation
do i=1,td%nedge
   if (td%edge_tri(1,i) == -1 .or. &
       (td%edge_bmark(i) == 0 .and. td%edge_tri(2,i) == -1)) then
      call fatal("didn't assign 2 triangles or 1 triangle and boundary mark to all edges in read_triangle_data")
      stop
   endif
end do

end subroutine read_triangle_data

!        -----------------
function find_point_bparam(piece,x,y,grid)
!        -----------------

!----------------------------------------------------
! This routine finds the parameter for the point (x,y) on boundary piece piece.
!
! The point must lie on this piece of the boundary or the routine will get
! stuck.  It uses a secant root finder to find the root of
! (x(s)-x)**2 - (y(s)-y)**2
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

integer, intent(in) :: piece
real(my_real), intent(in) :: x,y
real(my_real) :: find_point_bparam
type(grid_type), intent(in) :: grid
!----------------------------------------------------
! Local variables:

integer :: nstart, i
real(my_real) :: s_start, s_finish, s, s0, s1, s2, f0, f1, f2, xtry, ytry, &
                 xymag
real(my_real), parameter :: small_enough = 100*epsilon(0.0_my_real)
!----------------------------------------------------
! Begin executable code

! no parameter if the domain is defined from triangle data files, or the
! point is interior

if (boundary_npiece(0) <= 0 .or. piece == 0) then
   find_point_bparam = 0.0_my_real
   return
endif

! check the starting and finishing points

s_start = grid%bp_start(piece)
s_finish = grid%bp_finish(piece)
call boundary_point(piece,s_start,xtry,ytry)
xymag = max(1.0_my_real,sqrt(x*x+y*y))
if (sqrt((x-xtry)**2+(y-ytry)**2)/xymag < small_enough) then
   find_point_bparam = s_start
   return
endif

call boundary_point(piece,s_finish,xtry,ytry)
if (sqrt((x-xtry)**2+(y-ytry)**2) < small_enough) then
   find_point_bparam = s_finish
   return
endif

! begin by going through nstart equally spaced parameters to find the one
! that minimizes the target function

nstart = 100
f0 = huge(0.0_my_real)
do i=1,nstart-1
   s = s_start + i*((s_finish-s_start)/nstart)
   call boundary_point(piece,s,xtry,ytry)
   if ((x-xtry)**2+(y-ytry)**2 < f0) then
      f0 = (x-xtry)**2+(y-ytry)**2
      s0 = s
   endif
end do

! if found one that's good enough, return it

if (f0 < small_enough) then
   find_point_bparam = s0
   return
endif

! get a second starting point

s1 = s0 + (s_finish-s_start)/(10*nstart)
call boundary_point(piece,s1,xtry,ytry)
f1 = (x-xtry)**2+(y-ytry)**2

! perform secant method iteration until we are close enough.  The method
! fails if this goes into an infinite loop or a secant iteration finds a
! parameter that is out of the range of this piece's parameters.

do
   s2 = s1 - f1*(s1-s0)/(f1-f0)
   if (s2 < s_start .or. s2 > s_finish) then
      ierr = PHAML_INTERNAL_ERROR
      call fatal("secant method failed in find_point_bparam")
      stop
   endif
   call boundary_point(piece,s2,xtry,ytry)
   f2 = (x-xtry)**2+(y-ytry)**2
   if (f2 < small_enough) then
      find_point_bparam = s2
      return
   endif
   s0 = s1; s1 = s2; f0 = f1; f1 = f2
end do

end function find_point_bparam

!          --------------
subroutine match_periodic(grid,td,NO_MATE)
!          --------------

!----------------------------------------------------
! This routine matches pairs of sides that are periodic bounday so that
! the vertices align.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

type(grid_type), intent(in) :: grid
type(triangle_data), intent(inout) :: td
!----------------------------------------------------
! Local variables:

integer :: mark, astat, astat2, jerr, itemp, edge, i, m, edge1, edge2, vert1, &
           vert2, vert3, endvert(2,2), nseg(2), end1, end2, tri1, tri2, syssize
real(my_real) :: acclen1, acclen2, seglen1, seglen2, newacclen1, newacclen2, &
                 slope1, slope2, frac1, frac2, lenside(2)
integer :: first_edge(2), last_edge(2)
integer, pointer :: next_edge(:),prev_edge(:),assoc_tri(:)
logical, pointer :: swap(:)
logical :: rev(2), straight1, straight2
integer, intent(in) :: NO_MATE
!----------------------------------------------------

syssize = grid%system_size

! allocate space for linked lists

allocate(next_edge(td%nedge),prev_edge(td%nedge),assoc_tri(td%nedge), &
         stat=astat)

! swap indicates if the endpoints of an edge need to be visited in opposite
! order while traversing the boundary side

allocate(swap(td%nedge),stat=astat2)

if (astat /= 0 .or. astat2 /= 0) then
   ierr = ALLOC_FAILED
   call fatal("allocation failed in match_periodic")
   stop
endif

! one of the pair of periodic edges is required to have a negative bmark,
! while the matching edge is its absolute value.  Repeat for each
! negative bmark.

mark = -huge(0)
outer: do
   mark = minval(td%edge_bmark, mask=(td%edge_bmark > mark) )
   if (mark >= 0) exit

! for the boundary side with mark mark and its periodic companion with
! mark abs(mark) (aka -mark) create a linked list of consecutive boundary
! edges, and corresponding triangles.

   do m = mark, -mark, -2*mark
      if (m==mark) then
         i=1
      else
         i=2
      endif

      call list_mark(m,syssize,td,first_edge(i),last_edge(i),next_edge, &
                     prev_edge,assoc_tri,jerr) 

! if jerr=-1, then the negative mark was not used to designate a periodic side
! so nothing to do

      if (jerr == -1) cycle outer
   end do

! find the vertices at the ends of the boundary segments

   do i=1,2
      if (next_edge(first_edge(i)) == END_OF_LIST) then
         endvert(1,i) = td%edge_vert(1,first_edge(i))
      elseif (td%edge_vert(1,first_edge(i))== &
              td%edge_vert(1,next_edge(first_edge(i))) .or. &
              td%edge_vert(1,first_edge(i))== &
              td%edge_vert(2,next_edge(first_edge(i)))) then
         endvert(1,i) = td%edge_vert(2,first_edge(i))
      else
         endvert(1,i) = td%edge_vert(1,first_edge(i))
      endif
      if (prev_edge(last_edge(i)) == END_OF_LIST) then
         endvert(2,i) = td%edge_vert(2,last_edge(i))
      elseif (td%edge_vert(1,last_edge(i))== &
              td%edge_vert(1,prev_edge(last_edge(i))) .or. &
              td%edge_vert(1,last_edge(i))== &
              td%edge_vert(2,prev_edge(last_edge(i)))) then
         endvert(2,i) = td%edge_vert(2,last_edge(i))
      else
         endvert(2,i) = td%edge_vert(1,last_edge(i))
      endif
   end do

! attempt to find the direction to traverse the boundary segments so that the
! periodic conditions match
! TEMP this is not fool proof

   rev = .false.

! if the first and last x coordinates differ for both of them, then go from
! the small x to the large x

   if (td%vert_coord(endvert(1,1))%x /= td%vert_coord(endvert(2,1))%x .and. &
       td%vert_coord(endvert(1,2))%x /= td%vert_coord(endvert(2,2))%x) then
      if (td%vert_coord(endvert(1,1))%x > td%vert_coord(endvert(2,1))%x) then
         rev(1) = .true.
      endif
      if (td%vert_coord(endvert(1,2))%x > td%vert_coord(endvert(2,2))%x) then
         rev(2) = .true.
      endif

! if that failed, same idea with the y coordinate

   elseif (td%vert_coord(endvert(1,1))%y /= td%vert_coord(endvert(2,1))%y .and. &
           td%vert_coord(endvert(1,2))%y /= td%vert_coord(endvert(2,2))%y) then
      if (td%vert_coord(endvert(1,1))%y > td%vert_coord(endvert(2,1))%y) then
         rev(1) = .true.
      endif
      if (td%vert_coord(endvert(1,2))%y > td%vert_coord(endvert(2,2))%y) then
         rev(2) = .true.
      endif

! if that failed, put the end closer to the origin first

   else
      if (td%vert_coord(endvert(1,1))%x**2+td%vert_coord(endvert(1,1))%y**2 > &
          td%vert_coord(endvert(2,1))%x**2+td%vert_coord(endvert(2,1))%y**2) then
         rev(1) = .true.
      endif
      if (td%vert_coord(endvert(1,2))%x**2+td%vert_coord(endvert(1,2))%y**2 > &
          td%vert_coord(endvert(2,2))%x**2+td%vert_coord(endvert(2,2))%y**2) then
         rev(2) = .true.
      endif

   endif

! if either list wants to be reversed, reverse it

   do i=1,2
      if (rev(i)) then
         itemp = endvert(1,i)
         endvert(1,i) = endvert(2,i)
         endvert(2,i) = itemp
         edge = first_edge(i)
         itemp = first_edge(i)
         first_edge(i) = last_edge(i)
         last_edge(i) = itemp
         do
            if (edge == END_OF_LIST) exit
            itemp = next_edge(edge)
            next_edge(edge) = prev_edge(edge)
            prev_edge(edge) = itemp
            edge = itemp
         end do
      endif
   end do

! traverse each list to determine whether the first or second vertex of each
! edge matches the preceeding edge

   do i=1,2

! check starting point

      if (td%edge_vert(1,first_edge(i)) == endvert(1,i)) then
         swap(first_edge(i)) = .false.
      elseif (td%edge_vert(2,first_edge(i)) == endvert(1,i)) then
         swap(first_edge(i)) = .true.
      else
         ierr = PHAML_INTERNAL_ERROR
         call fatal("first vertex does not match endvert")
         stop
      endif

! traverse the list

      edge = first_edge(i)
      do
         if (edge == last_edge(i)) exit
         if (swap(edge)) then
            if (td%edge_vert(1,next_edge(edge)) == td%edge_vert(1,edge)) then
               swap(next_edge(edge)) = .false.
            elseif (td%edge_vert(2,next_edge(edge))==td%edge_vert(1,edge)) then
               swap(next_edge(edge)) = .true.
            else
               ierr = PHAML_INTERNAL_ERROR
               call fatal("first vertex does not match either vertex in next edge")
               stop
            endif
         else
            if (td%edge_vert(1,next_edge(edge)) == td%edge_vert(2,edge)) then
               swap(next_edge(edge)) = .false.
            elseif (td%edge_vert(2,next_edge(edge))==td%edge_vert(2,edge)) then
               swap(next_edge(edge)) = .true.
            else
               ierr = PHAML_INTERNAL_ERROR
               call fatal("second vertex does not match either vertex in next edge")
               stop
            endif
         endif

         edge = next_edge(edge)
      end do

! verify the last point

      if ((swap(edge).and.td%edge_vert(1,edge)/=endvert(2,i)) .or. &
          (.not.swap(edge).and.td%edge_vert(2,edge)/=endvert(2,i))) then
         ierr = PHAML_INTERNAL_ERROR
         call fatal("last point did not match second endvert")
         stop
      endif

   end do ! next boundary side

! count the number of edge segments in each list and compute the total
! length of each boundary side

   do i=1,2
      nseg(i) = 0
      lenside(i) = 0.0_my_real
      edge = first_edge(i)
      do
         if (edge == END_OF_LIST) exit
         end1 = td%edge_vert(1,edge)
         end2 = td%edge_vert(2,edge)
         lenside(i) = lenside(i) + &
                      (td%vert_coord(end1)%x - td%vert_coord(end2)%x)**2 + &
                      (td%vert_coord(end1)%y - td%vert_coord(end2)%y)**2
         nseg(i) = nseg(i) + 1
         edge = next_edge(edge)
      end do
   end do

! traverse the two boundary sides lining up the vertices according to
! fraction of total length.  If the number of segments are different,
! insert a new vertex when there is a large difference in the accumulated
! length

   edge1 = first_edge(1)
   edge2 = first_edge(2)
   acclen1 = 0.0_my_real
   acclen2 = 0.0_my_real

   do

! check for end of lists

      if (edge1 == END_OF_LIST) then
         if (edge2 == END_OF_LIST) then
            exit
         else
            ierr = PHAML_INTERNAL_ERROR
            call fatal("did not reach end of lists at same time when matching periodic boundaries")
            stop
         endif
      elseif (edge2 == END_OF_LIST) then
         ierr = PHAML_INTERNAL_ERROR
         call fatal("did not reach end of lists at same time when matching periodic boundaries")
         stop
      endif

! determine segment scaled lengths and new accumulations

      end1 = td%edge_vert(1,edge1)
      end2 = td%edge_vert(2,edge1)
      seglen1 = ((td%vert_coord(end1)%x - td%vert_coord(end2)%x)**2 + &
                 (td%vert_coord(end1)%y - td%vert_coord(end2)%y)**2)/lenside(1)
      newacclen1 = acclen1 + seglen1
      end1 = td%edge_vert(1,edge2)
      end2 = td%edge_vert(2,edge2)
      seglen2 = ((td%vert_coord(end1)%x - td%vert_coord(end2)%x)**2 + &
                 (td%vert_coord(end1)%y - td%vert_coord(end2)%y)**2)/lenside(2)
      newacclen2 = acclen2 + seglen2

! if no difference in the new accumulations, take it

      if (abs(newacclen1-newacclen2) < 10*epsilon(0.0_my_real)) then
         edge1 = next_edge(edge1)
         edge2 = next_edge(edge2)
         acclen1 = newacclen1
         acclen2 = newacclen2
         cycle
      endif

! if both lists are on the last section, take it.  If only one is on its
! last section, insert the required number of vertices in the other one

      if (next_edge(edge1) == END_OF_LIST) then
         if (next_edge(edge2) == END_OF_LIST) then
            edge1 = next_edge(edge1)
            edge2 = next_edge(edge2)
            acclen1 = newacclen1
            acclen2 = newacclen2
            cycle
         else
            call break_edge(grid,1,edge1,assoc_tri(edge1),nseg(2)-nseg(1),m, &
                            td,first_edge(1),last_edge(1),next_edge,prev_edge, &
                            assoc_tri,swap,NO_MATE)
            nseg(1) = nseg(2)
            cycle
         endif
      elseif (next_edge(edge2) == END_OF_LIST) then
         call break_edge(grid,2,edge2,assoc_tri(edge2),nseg(1)-nseg(2),m,td, &
                         first_edge(2),last_edge(2),next_edge,prev_edge, &
                         assoc_tri,swap,NO_MATE)
         nseg(2) = nseg(1)
         cycle
      endif

! note whether the current sections and the sections that follow form
! a straight line

      end1 = td%edge_vert(1,edge1)
      end2 = td%edge_vert(2,edge1)
      if (td%vert_coord(end2)%x == td%vert_coord(end1)%x) then
         slope1 = huge(0.0_my_real)/2
      else
         slope1 = (td%vert_coord(end2)%y-td%vert_coord(end1)%y) / &
                  (td%vert_coord(end2)%x-td%vert_coord(end1)%x)
      endif
      end1 = end2
      end2 = td%edge_vert(1,next_edge(edge1))
      if (td%vert_coord(end2)%x == td%vert_coord(end1)%x) then
         slope2 = huge(0.0_my_real)/2
      else
         slope2 = (td%vert_coord(end2)%y-td%vert_coord(end1)%y) / &
                  (td%vert_coord(end2)%x-td%vert_coord(end1)%x)
      endif
      straight1 = abs(slope1-slope2)<100*epsilon(0.0_my_real)

      end1 = td%edge_vert(1,edge2)
      end2 = td%edge_vert(2,edge2)
      if (td%vert_coord(end2)%x == td%vert_coord(end1)%x) then
         slope1 = huge(0.0_my_real)/2
      else
         slope1 = (td%vert_coord(end2)%y-td%vert_coord(end1)%y) / &
                  (td%vert_coord(end2)%x-td%vert_coord(end1)%x)
      endif
      end1 = end2
      end2 = td%edge_vert(1,next_edge(edge2))
      if (td%vert_coord(end2)%x == td%vert_coord(end1)%x) then
         slope2 = huge(0.0_my_real)/2
      else
         slope2 = (td%vert_coord(end2)%y-td%vert_coord(end1)%y) / &
                  (td%vert_coord(end2)%x-td%vert_coord(end1)%x)
      endif
      straight2 = abs(slope1-slope2)<100*epsilon(0.0_my_real)

! if the new accumulated lengths are well separated and the number of
! segments is not equal, then insert a new vertex in the longer one if
! the longer one has fewer segments

      if (abs(newacclen1-newacclen2) > max(seglen1,seglen2)/2 .and. &
          nseg(1) /= nseg(2)) then

         if (nseg(1) > nseg(2) .and. newacclen2 > newacclen1) then
            call break_edge(grid,2,edge2,assoc_tri(edge2),1,m,td, &
                            first_edge(2),last_edge(2),next_edge,prev_edge, &
                            assoc_tri,swap,NO_MATE)
            nseg(2) = nseg(2) + 1
            cycle
         elseif (nseg(2) > nseg(1) .and. newacclen1 > newacclen2) then
            call break_edge(grid,1,edge1,assoc_tri(edge1),1,m,td, &
                            first_edge(1),last_edge(1),next_edge,prev_edge, &
                            assoc_tri,swap,NO_MATE)
            nseg(1) = nseg(1) + 1
            cycle
         endif
      endif

! otherwise, move the vertices at the end of the current segments to agree,
! depending on which are on straight lines

! TEMP is there a possibility of degenerating triangles here?

      if (straight1) then
         if (straight2) then
            newacclen1 = (newacclen1+newacclen2)/2
            newacclen2 = newacclen1
            frac1 = (newacclen1-acclen1)/seglen1
            frac2 = (newacclen2-acclen2)/seglen2
            seglen1 = newacclen1 - acclen1
            seglen2 = newacclen2 - acclen2
         else
            newacclen1 = newacclen2
            frac1 = (newacclen1-acclen1)/seglen1
            seglen1 = newacclen1 - acclen1
            frac2 = 1
         endif
      elseif (straight2) then
         newacclen2 = newacclen1
         frac2 = (newacclen2-acclen2)/seglen2
         seglen2 = newacclen2 - acclen2
         frac1 = 1
      endif

      tri1 = assoc_tri(edge1)
      do i=1,3
         if (td%tri_vert(i,tri1) /= td%edge_vert(1,edge1) .and. &
             td%tri_vert(i,tri1) /= td%edge_vert(2,edge1)) then
            vert3 = td%tri_vert(i,tri1)
         endif
      end do
      call point_on_edge(grid, &
                         td%vert_coord(td%edge_vert(1,edge1))%x, &
                         td%vert_coord(td%edge_vert(1,edge1))%y, &
                         td%vert_bmark(td%edge_vert(1,edge1)), &
                         td%vert_bparam(td%edge_vert(1,edge1)), &
                         td%vert_coord(td%edge_vert(2,edge1))%x, &
                         td%vert_coord(td%edge_vert(2,edge1))%y, &
                         td%vert_bmark(td%edge_vert(2,edge1)), &
                         td%vert_bparam(td%edge_vert(2,edge1)), &
                         td%vert_coord(vert3)%x, td%vert_coord(vert3)%y, &
                         td%edge_bmark(edge1), frac1, &
                         td%vert_coord(td%edge_vert(2,edge1))%x, &
                         td%vert_coord(td%edge_vert(2,edge1))%y, &
                         td%vert_bparam(td%edge_vert(2,edge1)))
      tri1 = assoc_tri(edge2)
      do i=1,3
         if (td%tri_vert(i,tri1) /= td%edge_vert(1,edge2) .and. &
             td%tri_vert(i,tri1) /= td%edge_vert(2,edge2)) vert3 = td%tri_vert(i,tri1)
      end do
      call point_on_edge(grid, &
                         td%vert_coord(td%edge_vert(1,edge2))%x, &
                         td%vert_coord(td%edge_vert(1,edge2))%y, &
                         td%vert_bmark(td%edge_vert(1,edge2)), &
                         td%vert_bparam(td%edge_vert(1,edge2)), &
                         td%vert_coord(td%edge_vert(2,edge2))%x, &
                         td%vert_coord(td%edge_vert(2,edge2))%y, &
                         td%vert_bmark(td%edge_vert(2,edge2)), &
                         td%vert_bparam(td%edge_vert(2,edge2)), &
                         td%vert_coord(vert3)%x, td%vert_coord(vert3)%y, &
                         td%edge_bmark(edge2), frac2, &
                         td%vert_coord(td%edge_vert(2,edge2))%x, &
                         td%vert_coord(td%edge_vert(2,edge2))%y, &
                         td%vert_bparam(td%edge_vert(2,edge2)))

      edge1 = next_edge(edge1)
      edge2 = next_edge(edge2)
      acclen1 = newacclen1
      acclen2 = newacclen2

   end do ! next segment of both sides

! traverse the edge lists to make the corresponding elements neighbors

   edge1 = first_edge(1)
   edge2 = first_edge(2)

   if (swap(edge1)) then
      vert1 = td%edge_vert(2,edge1)
   else
      vert1 = td%edge_vert(1,edge1)
   endif
   if (swap(edge2)) then
      vert2 = td%edge_vert(2,edge2)
   else
      vert2 = td%edge_vert(1,edge2)
   endif
   if (td%edge_bmark(edge1) < 0) td%vert_master(vert1) = vert2
   if (td%edge_bmark(edge2) < 0) td%vert_master(vert2) = vert1

   do
      if (edge1 == END_OF_LIST) then
         if (edge2 == END_OF_LIST) then
            exit
         else
            ierr = PHAML_INTERNAL_ERROR
            call fatal("did not reach end of lists at same time when matching periodic boundaries")
            stop
         endif
      elseif (edge2 == END_OF_LIST) then
         ierr = PHAML_INTERNAL_ERROR
         call fatal("did not reach end of lists at same time when matching periodic boundaries")
         stop
      endif

      tri1 = assoc_tri(edge1)
      tri2 = assoc_tri(edge2)
      do i=1,3
         if (td%tri_vert(i,tri1) /= td%edge_vert(1,edge1) .and. &
             td%tri_vert(i,tri1) /= td%edge_vert(2,edge1)) then
            td%tri_neigh(i,tri1) = tri2
            exit
         endif
      end do
      do i=1,3
         if (td%tri_vert(i,tri2) /= td%edge_vert(1,edge2) .and. &
             td%tri_vert(i,tri2) /= td%edge_vert(2,edge2)) then
            td%tri_neigh(i,tri2) = tri1
            exit
         endif
      end do

      if (swap(edge1)) then
         vert1 = td%edge_vert(1,edge1)
      else
         vert1 = td%edge_vert(2,edge1)
      endif
      if (swap(edge2)) then
         vert2 = td%edge_vert(1,edge2)
      else
         vert2 = td%edge_vert(2,edge2)
      endif
      if (td%edge_bmark(edge1) < 0) td%vert_master(vert1) = vert2
      if (td%edge_bmark(edge2) < 0) td%vert_master(vert2) = vert1

      edge1 = next_edge(edge1)
      edge2 = next_edge(edge2)
   end do

end do outer ! next negative mark

deallocate(swap,next_edge,prev_edge,assoc_tri,stat=astat)

end subroutine match_periodic

!          ---------
subroutine list_mark(m,syssize,td,first_edge,last_edge,next_edge,prev_edge, &
                     assoc_tri,jerr)
!          ---------

!----------------------------------------------------
! This routine creates a linked list of edges that have bmark m, and the
! triangles containing those edges.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

integer, intent(in) :: m,syssize
type(triangle_data), intent(in) :: td
integer, intent(out) :: first_edge, last_edge
integer, intent(out) :: next_edge(:),prev_edge(:),assoc_tri(:)
integer, intent(out) :: jerr
!----------------------------------------------------
! Local variables:

integer :: tri, edge, vert, itype(syssize), tri0, edge0, dir, &
           vert1, vert2, i, j, k, newedge, newtri
real(my_real) :: c(syssize,syssize), rs(syssize)
!----------------------------------------------------
! Begin executable code

jerr = 0

! find some edge with bmark m

first_edge = END_OF_LIST
do edge=1,td%nedge
   if (td%edge_bmark(edge) == m) then
      first_edge = edge
      last_edge = edge
      next_edge(edge) = END_OF_LIST
      prev_edge(edge) = END_OF_LIST
      exit
   endif
end do

if (first_edge == END_OF_LIST) then
   ierr = PHAML_INTERNAL_ERROR
   call fatal("failed to find an edge with bmark ",intlist=(/m/))
   stop
endif

! find a triangle containing this edge

vert1 = td%edge_vert(1,edge)
vert2 = td%edge_vert(2,edge)
assoc_tri(edge) = -1
outer: do i=1,td%ntri
   do j=1,3
      if (td%tri_vert(j,i) == vert1) then
         do k=1,3
            if (td%tri_vert(k,i) == vert2) then
               assoc_tri(edge) = i
               exit outer
            endif
         end do
      end if
   end do
end do outer

if (assoc_tri(edge) == -1) then
   ierr = PHAML_INTERNAL_ERROR
   call fatal("failed to find a triangle with the edge")
   stop
endif

! check the boundary condition type for this edge.  If it is not PERIODIC and
! bmark is negative, then they simply used a negative bmark.  But if it is
! not PERIODIC and bmark is positive, then they did not designate the matching
! of periodic sides with +-bmark

! point may not be on curved boundary, but I'm only after itype
call bconds((td%vert_coord(td%edge_vert(1,edge))%x + &
             td%vert_coord(td%edge_vert(2,edge))%x)/2, &
            (td%vert_coord(td%edge_vert(1,edge))%y + &
             td%vert_coord(td%edge_vert(2,edge))%y)/2, &
            m,itype,c,rs)
if (all(itype /= PERIODIC)) then
   if (m < 0) then
      jerr = -1
      return
   else
      ierr = USER_INPUT_ERROR
      call fatal("boundary side with given bmark does not have PERIODIC", &
                "boundary conditions but the negative of it does",intlist=(/m/))
      stop
   endif
endif

! traverse the boundary in both directions from the found edge until
! the bmark changes, building a linked list of edges and triangles

tri0 = assoc_tri(edge)
edge0 = edge

do dir=1,2
   tri = tri0
   edge = edge0
   vert = td%edge_vert(dir,edge0)

   do

! find the other boundary edge that contains vert.

      do newedge=1,td%nedge
         if (td%edge_bmark(newedge) == 0) cycle ! interior edge
         if (newedge == edge) cycle ! same edge
         if (td%edge_vert(1,newedge) == vert .or. &
             td%edge_vert(2,newedge) == vert) exit
      end do

      if (newedge > td%nedge) then
         ierr = PHAML_INTERNAL_ERROR
         call fatal("couldn't find second edge with given vertex in list_mark",&
                    intlist=(/vert/))
         stop
      endif

! if bmark is m, put this on the list and continue.  if not, we have passed
! this end of the boundary segment with bmark m

      if (td%edge_bmark(newedge) == m) then
         if (dir == 1) then
            prev_edge(edge) = newedge
            next_edge(newedge) = edge
            prev_edge(newedge) = END_OF_LIST
            first_edge = newedge
         else
            next_edge(edge) = newedge
            prev_edge(newedge) = edge
            next_edge(newedge) = END_OF_LIST
            last_edge = newedge
         endif
         vert1 = td%edge_vert(1,newedge)
         vert2 = td%edge_vert(2,newedge)
         assoc_tri(newedge) = -1
outer3:  do i=1,td%ntri
            do j=1,3
               if (td%tri_vert(j,i) == vert1) then
                  do k=1,3
                     if (td%tri_vert(k,i) == vert2) then
                        newtri = i
                        exit outer3
                     endif
                  end do
               end if
            end do
         end do outer3
         assoc_tri(newedge) = newtri
         tri = newtri
         edge = newedge
         if (td%edge_vert(1,edge) == vert) then
            vert = td%edge_vert(2,edge)
         else
            vert = td%edge_vert(1,edge)
         endif
      else
         exit
      endif
   end do
end do

end subroutine list_mark

!          ----------
subroutine break_edge(grid,bside,edge,tri,nbreak,m,td,first_edge,last_edge, &
                      next_edge,prev_edge,assoc_tri,swap,NO_MATE)
!          ----------

!----------------------------------------------------
! This routine breaks an edge into nbreak equal pieces by refining triangle
! tri into nbreak+1 triangles by dividing from the vertex opposite edge edge

! TEMP some of the components of td (tri_edge, edge_tri, vert_tri, vert_edge)
! do not get redefined in here.  I'm not sure if that matters.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

type(grid_type), intent(in) :: grid
integer, intent(in) :: bside, edge, tri, nbreak, m
type(triangle_data), intent(inout) :: td
integer, intent(inout) :: first_edge, last_edge
integer, pointer :: next_edge(:), prev_edge(:), assoc_tri(:)
logical, pointer :: swap(:)
integer, intent(in) :: NO_MATE
!----------------------------------------------------
! Local variables:

integer :: i, new_nvert, new_ntri, new_nedge, oppvert, astat, vert, last, j, &
           lastneigh, lastloc
real(my_real) :: f
type(point), pointer :: new_vert_coord(:)
integer, pointer :: new_tri_edge(:,:), new_tri_vert(:,:), new_tri_neigh(:,:), new_edge_tri(:,:), new_edge_vert(:,:), &
                    new_vert_tri(:,:), new_vert_edge(:,:), new_vert_bmark(:), new_edge_bmark(:), new_next(:), &
                    new_prev(:), new_assoc(:), new_vert_master(:)
real(my_real), pointer :: new_vert_bparam(:)
logical, pointer :: new_swap(:)
real(my_real) :: xtemp, ytemp
!----------------------------------------------------
! Begin executable code

! reallocate space for new entities

new_nvert = td%nvert + nbreak
new_ntri = td%ntri + nbreak
new_nedge = td%nedge + 2*nbreak

allocate(new_vert_coord(new_nvert), new_tri_edge(3,new_ntri), &
         new_tri_vert(3,new_ntri), new_tri_neigh(3,new_ntri), &
         new_edge_tri(2,new_nedge), new_edge_vert(2,new_nedge), &
         new_vert_bmark(new_nvert), new_vert_tri(MAX_TD_VERT_NEIGH,new_nvert), &
         new_vert_edge(MAX_TD_VERT_NEIGH,new_nvert), &
         new_vert_bparam(new_nvert), new_edge_bmark(new_nedge), &
         new_next(new_nedge), new_prev(new_nedge), new_assoc(new_nedge), &
         new_swap(new_nedge), new_vert_master(new_nvert),stat=astat)
if (astat /= 0) then
   ierr = ALLOC_FAILED
   call fatal("allocation failed in break_edge")
   stop
endif

! copy existing data to new location

new_vert_coord(1:td%nvert) = td%vert_coord
new_tri_edge(:,1:td%ntri) = td%tri_edge
new_tri_vert(:,1:td%ntri) = td%tri_vert
new_tri_neigh(:,1:td%ntri) = td%tri_neigh
new_edge_tri(:,1:td%nedge) = td%edge_tri
new_edge_vert(:,1:td%nedge) = td%edge_vert
new_vert_tri(:,1:td%nvert) = td%vert_tri
new_vert_edge(:,1:td%nvert) = td%vert_edge
new_vert_bmark(1:td%nvert) = td%vert_bmark
new_vert_bparam(1:td%nvert) = td%vert_bparam
new_edge_bmark(1:td%nedge) = td%edge_bmark
new_next(1:td%nedge) = next_edge
new_prev(1:td%nedge) = prev_edge
new_assoc(1:td%nedge) = assoc_tri
new_vert_master(1:td%nvert) = td%vert_master
new_vert_master(td%nvert+1:new_nvert) = NO_MATE
new_swap(1:td%nedge) = swap

! free old memory

deallocate(td%vert_coord,td%tri_edge,td%tri_vert,td%tri_neigh,td%edge_tri, &
           td%edge_vert,td%vert_tri,td%vert_edge,td%vert_bmark, &
           td%vert_bparam,td%edge_bmark,next_edge,prev_edge,assoc_tri, &
           td%vert_master,swap,stat=astat)
if (astat/=0) then
   call warning("deallocation failed in break_edge")
endif

! set standard names to new memory

td%vert_coord => new_vert_coord
td%tri_edge => new_tri_edge
td%tri_vert => new_tri_vert
td%tri_neigh => new_tri_neigh
td%edge_tri => new_edge_tri
td%edge_vert => new_edge_vert
td%vert_tri => new_vert_tri
td%vert_edge => new_vert_edge
td%vert_bmark => new_vert_bmark
td%vert_bparam => new_vert_bparam
td%edge_bmark => new_edge_bmark
next_edge => new_next
prev_edge => new_prev
assoc_tri => new_assoc
td%vert_master => new_vert_master
swap => new_swap

! find the opposite vertex in the associated triangle

do vert=1,3
   if (td%tri_vert(vert,tri) /= td%edge_vert(1,edge) .and. &
       td%tri_vert(vert,tri) /= td%edge_vert(2,edge)) exit
end do
oppvert = td%tri_vert(vert,tri)

! define the new vertices

do i=1,nbreak
   f = i/(nbreak+1.0_my_real)
   if (swap(edge)) f = 1-f
   call point_on_edge(grid, &
                      td%vert_coord(td%edge_vert(1,edge))%x, &
                      td%vert_coord(td%edge_vert(1,edge))%y, &
                      td%vert_bmark(td%edge_vert(1,edge)), &
                      td%vert_bparam(td%edge_vert(1,edge)), &
                      td%vert_coord(td%edge_vert(2,edge))%x, &
                      td%vert_coord(td%edge_vert(2,edge))%y, &
                      td%vert_bmark(td%edge_vert(2,edge)), &
                      td%vert_bparam(td%edge_vert(2,edge)), &
                      td%vert_coord(oppvert)%x, td%vert_coord(oppvert)%y, m,f, &
                      xtemp, ytemp, &
                      td%vert_bparam(td%nvert+i))
   td%vert_coord(td%nvert+i)%x = xtemp
   td%vert_coord(td%nvert+i)%y = ytemp
   td%vert_bmark(td%nvert+i) = m
end do

! define the new edges that replace the edge being broken.  The first one
! overwrites the existing one.

if (swap(edge)) then
   last = td%edge_vert(1,edge)
   td%edge_vert(1,edge) = td%nvert + 1
else
   last = td%edge_vert(2,edge)
   td%edge_vert(2,edge) = td%nvert + 1
endif

do i=1,nbreak-1
   td%edge_vert(1,td%nedge+i) = td%nvert + i
   td%edge_vert(2,td%nedge+i) = td%nvert + i + 1
   swap(td%nedge+i) = .false.
   td%edge_bmark(td%nedge+i) = m
end do

td%edge_vert(1,td%nedge+nbreak) = td%nvert + nbreak
td%edge_vert(2,td%nedge+nbreak) = last
swap(td%nedge+nbreak) = .false.
td%edge_bmark(td%nedge+nbreak) = m

! define the edges that slice through the triangle being broken

do i=1,nbreak
   td%edge_vert(1,td%nedge+nbreak+i) = oppvert
   td%edge_vert(2,td%nedge+nbreak+i) = td%nvert + i
   swap(td%nedge+nbreak+i) = .false.
   td%edge_bmark(td%nedge+nbreak+i) = m
end do

! define the new triangles; the first one overwrites the existing one

do i=1,3
   if (td%tri_vert(i,tri) == last) td%tri_vert(i,tri) = td%nvert + 1
end do
do j=1,nbreak
   td%tri_vert(1,td%ntri+j) = oppvert
   td%tri_vert(2,td%ntri+j) = td%nvert + j
   td%tri_vert(3,td%ntri+j) = td%nvert + j + 1
end do
td%tri_vert(3,td%ntri+nbreak) = last

! set the new neighbors

lastneigh = -1
outer1: do i=1,3
   lastneigh = td%tri_neigh(i,tri)
   if (lastneigh <= 0) cycle
   do j=1,3
      lastloc = j
      if (td%tri_vert(j,lastneigh) == last) exit outer1
   enddo
end do outer1

if (i > 3) then
   ierr = PHAML_INTERNAL_ERROR
   call fatal("didn't find last neighbor")
   stop
endif

td%tri_neigh(lastloc,tri) = td%ntri + 1
do i=1,nbreak
   td%tri_neigh(1,td%ntri+i) = -1
   td%tri_neigh(2,td%ntri+i) = td%ntri + i + 1
   td%tri_neigh(3,td%ntri+i) = td%ntri + i - 1
end do
td%tri_neigh(3,td%ntri+1) = tri
td%tri_neigh(2,td%ntri+nbreak) = lastneigh

! set the linked lists and associated triangle

last = next_edge(edge)
do i=1,nbreak
   prev_edge(td%nedge+i) = td%nedge + i - 1
   next_edge(td%nedge+i) = td%nedge + i + 1
   assoc_tri(td%nedge+i) = tri
end do
next_edge(edge) = td%nedge + 1
prev_edge(td%nedge+1) = edge
next_edge(td%nedge+nbreak) = last
if (last /= END_OF_LIST) then
   prev_edge(last) = td%nedge+nbreak
else
   last_edge = td%nedge+nbreak
endif

! set new counts

td%nvert = new_nvert
td%ntri = new_ntri
td%nedge = new_nedge

end subroutine break_edge

!          --------------
subroutine pair_triangles(td,mate,NO_MATE)
!          --------------

!----------------------------------------------------
! This routine pairs up most of the triangles in the grid given by td.
!
! In this version, make one pass through the triangles pairing each
! unpaired triangle with the unpaired neighbor opposite the largest angle.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

type(triangle_data), intent(in) :: td
integer, intent(inout) :: mate(:)
integer, intent(in) :: NO_MATE
!----------------------------------------------------
! Local variables:

real(my_real) :: cos_angle(3,size(mate))
integer :: i, j, maxang
real(my_real) :: x1, x2, x3, y1, y2, y3, dx1, dx2, dy1, dy2, denom, mincos
!----------------------------------------------------
! Begin executable code

! compute the cosines of the angles of all the triangles

do i=1,td%ntri
   do j=1,3
      x1 = td%vert_coord(td%tri_vert(j,i))%x
      y1 = td%vert_coord(td%tri_vert(j,i))%y
      x2 = td%vert_coord(td%tri_vert(1+mod(j+1,3),i))%x
      y2 = td%vert_coord(td%tri_vert(1+mod(j+1,3),i))%y
      x3 = td%vert_coord(td%tri_vert(1+mod(j,3),i))%x
      y3 = td%vert_coord(td%tri_vert(1+mod(j,3),i))%y
      dx1 = x2-x1
      dy1 = y2-y1
      dx2 = x3-x1
      dy2 = y3-y1
      denom = sqrt((dx1*dx1+dy1*dy1)*(dx2*dx2+dy2*dy2))
      cos_angle(j,i) = (dx1*dx2+dy1*dy2)/denom
   end do
end do

! for each triangle not already assigned a mate

do i=1,td%ntri
   if (mate(i) /= NO_MATE) cycle


! find the largest angle (smallest cosine) opposite an unassigned or boundary
! neighbor

   maxang = -1
   mincos = 2.0_my_real
   do j=1,3
      if (td%tri_neigh(j,i) == -1) then
         if (cos_angle(j,i) < mincos .and. &
             abs(cos_angle(j,i)-mincos) > 100*epsilon(0.0_my_real)) then
            mincos = cos_angle(j,i)
            maxang = j
         endif
      elseif (mate(td%tri_neigh(j,i)) == NO_MATE) then
         if (cos_angle(j,i) < mincos .and. &
             abs(cos_angle(j,i)-mincos) > 100*epsilon(0.0_my_real)) then
            mincos = cos_angle(j,i)
            maxang = j
         endif
      endif
   end do

! set mate to indicate which of the three angles the mate is opposite

   if (maxang /= -1) then
      mate(i) = maxang

! if the mate is not the boundary, then find the angle in mate opposite
! triangle i and set its mate

      if (td%tri_neigh(maxang,i) /= -1) then
         do j=1,3
            if (td%tri_neigh(j,td%tri_neigh(maxang,i)) == i) then
               mate(td%tri_neigh(maxang,i)) = j
            endif
         end do
      endif

   endif

end do

end subroutine pair_triangles

!          ------------
subroutine refine_start(grid,td,mate,elemedge_bmark,NO_MATE)
!          ------------

!----------------------------------------------------
! This routine refines the starting grid in mate and td
! by bisecting those that have mates and trisecting those that don't.  It
! creates the following components of grid:
! vertex%coord, element%gid, element%mate, element%vertex, nelem, nvert,
! initial_neighbor
! It also sets vertex%assoc_elem to be the master vertex for vertices that
! are PERIODIC_SLAVE (negative bmark) or the endpoint of a PERIODIC_SLAVE
! side, and NO_MATE for all other vertices. This is just a convenient component
! to use for temporary storage.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

type(grid_type), intent(inout) :: grid
type(triangle_data), intent(in) :: td
integer, intent(inout) :: mate(:)
integer, intent(in) :: NO_MATE
integer, intent(out) :: elemedge_bmark(:,:)
!----------------------------------------------------
! Local variables:

integer :: i, j, k, next_vert, next_elem, &
           next_gid, tri, neigh, my_neigh, peak, old1, old2, peakm, old1m, &
           old2m, my_mate, stat, edge, bound_periodic_nvert, refedge, refedgem
integer :: refined_to(3,size(mate)), vert_edges(32,td%nvert)
!----------------------------------------------------
! Begin executable code

! determine the number of vertices and elements in the initial grid

bound_periodic_nvert = 0
grid%nvert = td%nvert
grid%nelem = 0
do i=1,td%ntri
   if (mate(i) == NO_MATE) then
      grid%nvert = grid%nvert + 1
      grid%nelem = grid%nelem + 3
   elseif (td%tri_neigh(mate(i),i) == -1) then ! boundary mate
      grid%nvert = grid%nvert + 1
      grid%nelem = grid%nelem + 2
   elseif (td%tri_neigh(mate(i),i) > i) then ! count pair when encountering first
      grid%nvert = grid%nvert + 1
      grid%nelem = grid%nelem + 4
   endif
   do j=1,EDGES_PER_ELEMENT
      if (td%vert_bmark(td%tri_vert(j,i)) < 0) then
         bound_periodic_nvert = bound_periodic_nvert + 1
      endif
   end do
end do

! make sure initial grid was allocated big enough and allocate initial_neighbor

if (size(grid%vertex) < grid%nvert + bound_periodic_nvert) then
   deallocate(grid%vertex)
   allocate(grid%vertex(2*grid%nvert),stat=stat)
   if (stat /= 0) then
      call fatal("allocation failed for grid%vertex in refine_start", &
                 intlist=(/grid%nvert/))
      stop
   endif
endif
if (size(grid%element) < grid%nelem) then
   deallocate(grid%element)
   allocate(grid%element(2*grid%nelem),stat=stat)
   if (stat /= 0) then
      call fatal("allocation failed for grid%element in refine_start", &
                 intlist=(/grid%nelem/))
      stop
   endif
endif
allocate(grid%initial_neighbor(EDGES_PER_ELEMENT,grid%nelem),stat=stat)
if (stat /= 0) then
   call fatal("allocation failed for grid%initial_neighbor in refine_start", &
              intlist=(/grid%nelem/))
   stop
endif

next_gid = grid%nelem

! copy vertex coordinates, boundary markers, and masters for PERIODIC_SLAVEs
! to grid data structure.  assoc_elem is used as temporary storage for masters.

do i=1,td%nvert
   grid%vertex(i)%coord = td%vert_coord(i)
   grid%vertex(i)%bmark = td%vert_bmark(i)
   grid%vertex(i)%bparam = td%vert_bparam(i)
   grid%vertex(i)%assoc_elem = td%vert_master(i)
end do
next_vert = td%nvert+1

! invert the mapping between edges and vertices

vert_edges = -1
do i=1,td%nedge
   do k=1,2
      do j=1,size(vert_edges,dim=1)
         if (vert_edges(j,td%edge_vert(k,i)) == -1) exit
      end do
      if (j > size(vert_edges,dim=1)) then
         call fatal("need bigger dimension for vert_edges")
         stop
      endif
      vert_edges(j,td%edge_vert(k,i)) = i
   end do
end do

! pass through elements, refining them and creating remainder of grid data

refined_to = -1
next_elem = 1
do tri=1,td%ntri

! see if it is already refined

   if (refined_to(1,tri) /= -1) cycle

! no mate, trisect it

   if (mate(tri) == NO_MATE) then

      grid%vertex(next_vert)%coord%x = sum(td%vert_coord(td%tri_vert(:,tri))%x)/3
      grid%vertex(next_vert)%coord%y = sum(td%vert_coord(td%tri_vert(:,tri))%y)/3
      grid%vertex(next_vert)%bmark = 0
      grid%vertex(next_vert)%assoc_elem = NO_MATE

      grid%element(next_elem  )%vertex(1) = td%tri_vert(2,tri)
      grid%element(next_elem  )%vertex(2) = td%tri_vert(3,tri)
      grid%element(next_elem  )%vertex(3) = next_vert

      grid%element(next_elem+1)%vertex(1) = td%tri_vert(3,tri)
      grid%element(next_elem+1)%vertex(2) = td%tri_vert(1,tri)
      grid%element(next_elem+1)%vertex(3) = next_vert

      grid%element(next_elem+2)%vertex(1) = td%tri_vert(1,tri)
      grid%element(next_elem+2)%vertex(2) = td%tri_vert(2,tri)
      grid%element(next_elem+2)%vertex(3) = next_vert

      grid%element(next_elem  )%gid = next_gid
      grid%element(next_elem+1)%gid = next_gid+1
      grid%element(next_elem+2)%gid = next_gid+2

      refined_to(1,tri) = next_elem
      refined_to(2,tri) = next_elem+1
      refined_to(3,tri) = next_elem+2

      do j=0,2
         elemedge_bmark(:,next_elem+j) = 0
         do i=1,size(vert_edges,dim=1)
            edge = vert_edges(i,grid%element(next_elem+j)%vertex(1))
            if (edge == -1) exit
            if (td%edge_vert(1,edge) == grid%element(next_elem+j)%vertex(2) .or. &
                td%edge_vert(2,edge) == grid%element(next_elem+j)%vertex(2)) exit
         end do
         if (edge == -1 .or. i > size(vert_edges,dim=1)) then
            call fatal("failed to find edge")
            stop
         endif
         elemedge_bmark(3,next_elem+j) = td%edge_bmark(edge)
      end do

      grid%initial_neighbor(1,next_elem  ) = next_elem+1
      grid%initial_neighbor(2,next_elem  ) = next_elem+2
      grid%initial_neighbor(3,next_elem  ) = -1

      grid%initial_neighbor(1,next_elem+1) = next_elem+2
      grid%initial_neighbor(2,next_elem+1) = next_elem
      grid%initial_neighbor(3,next_elem+1) = -1

      grid%initial_neighbor(1,next_elem+2) = next_elem
      grid%initial_neighbor(2,next_elem+2) = next_elem+1
      grid%initial_neighbor(3,next_elem+2) = -1

      do j=1,3
         neigh = td%tri_neigh(j,tri)

         if (neigh == -1) then
            grid%initial_neighbor(3,next_elem+j-1) = BOUNDARY
            grid%element(next_elem+j-1)%mate = BOUNDARY
            cycle
         endif

         if (refined_to(1,neigh) == -1) cycle ! wait until neighbor is refined

         my_neigh = find_neigh(refined_to(:,neigh), &
                               grid%element(next_elem+j-1)%vertex, &
                               grid%element,grid%vertex)
         grid%initial_neighbor(3,next_elem+j-1) = my_neigh
         grid%element(next_elem+j-1)%mate = grid%element(my_neigh)%gid
         grid%initial_neighbor(3,my_neigh) = next_elem+j-1
         grid%element(my_neigh)%mate = grid%element(next_elem+j-1)%gid
      end do

      next_vert = next_vert + 1
      next_elem = next_elem + 3
      next_gid = next_gid + 3

! mate is boundary, bisect tri

   elseif (td%tri_neigh(mate(tri),tri) == -1) then

      peak = mate(tri)
      old1 = 1
      old2 = 2
      if (peak == 1) old1 = 3
      if (peak == 2) old2 = 3

      do i=1,size(vert_edges,dim=1)
         edge = vert_edges(i,td%tri_vert(old1,tri))
         if (edge == -1) exit
         if (td%edge_vert(1,edge) == td%tri_vert(old2,tri) .or. &
             td%edge_vert(2,edge) == td%tri_vert(old2,tri)) exit
      end do
      if (edge == -1 .or. i > size(vert_edges,dim=1)) then
         call fatal("failed to find edge")
         stop
      endif

      call point_on_edge(grid, &
                         td%vert_coord(td%tri_vert(old1,tri))%x, &
                         td%vert_coord(td%tri_vert(old1,tri))%y, &
                         td%vert_bmark(td%tri_vert(old1,tri)), &
                         td%vert_bparam(td%tri_vert(old1,tri)), &
                         td%vert_coord(td%tri_vert(old2,tri))%x, &
                         td%vert_coord(td%tri_vert(old2,tri))%y, &
                         td%vert_bmark(td%tri_vert(old2,tri)), &
                         td%vert_bparam(td%tri_vert(old2,tri)), &
                         td%vert_coord(td%tri_vert(peak,tri))%x, &
                         td%vert_coord(td%tri_vert(peak,tri))%y, &
                         td%edge_bmark(edge), &
                         0.5_my_real, &
                         grid%vertex(next_vert)%coord%x, &
                         grid%vertex(next_vert)%coord%y, &
                         grid%vertex(next_vert)%bparam)
      grid%vertex(next_vert)%bmark = td%edge_bmark(edge)
      grid%vertex(next_vert)%assoc_elem = NO_MATE

      grid%element(next_elem  )%vertex(1) = td%tri_vert(peak,tri)
      grid%element(next_elem  )%vertex(2) = td%tri_vert(old1,tri)
      grid%element(next_elem  )%vertex(3) = next_vert

      grid%element(next_elem+1)%vertex(1) = td%tri_vert(peak,tri)
      grid%element(next_elem+1)%vertex(2) = td%tri_vert(old2,tri)
      grid%element(next_elem+1)%vertex(3) = next_vert

      grid%element(next_elem  )%gid = next_gid
      grid%element(next_elem+1)%gid = next_gid+1

      refined_to(1,tri) = next_elem
      refined_to(2,tri) = next_elem+1
      refined_to(3,tri) = -1

      do j=0,1
         elemedge_bmark(:,next_elem+j) = 0
         elemedge_bmark(1,next_elem+j) = grid%vertex(next_vert)%bmark
         do i=1,size(vert_edges,dim=1)
            edge = vert_edges(i,grid%element(next_elem+j)%vertex(1))
            if (edge == -1) exit
            if (td%edge_vert(1,edge) == grid%element(next_elem+j)%vertex(2) .or. &
                td%edge_vert(2,edge) == grid%element(next_elem+j)%vertex(2)) exit
         end do
         if (edge == -1 .or. i > size(vert_edges,dim=1)) then
            call fatal("failed to find edge")
            stop
         endif
         elemedge_bmark(3,next_elem+j) = td%edge_bmark(edge)
      end do

      grid%initial_neighbor(1,next_elem  ) = BOUNDARY
      grid%initial_neighbor(2,next_elem  ) = next_elem+1
      grid%initial_neighbor(3,next_elem  ) = -1

      grid%initial_neighbor(1,next_elem+1) = BOUNDARY
      grid%initial_neighbor(2,next_elem+1) = next_elem
      grid%initial_neighbor(3,next_elem+1) = -1

      do j=1,2
         if (j == 1) then
            neigh = td%tri_neigh(old2,tri)
         else
            neigh = td%tri_neigh(old1,tri)
         endif

         if (neigh == -1) then
            grid%initial_neighbor(3,next_elem+j-1) = BOUNDARY
            grid%element(next_elem+j-1)%mate = BOUNDARY
            cycle
         endif

         if (refined_to(1,neigh) == -1) cycle ! wait until neighbor is refined

         my_neigh = find_neigh(refined_to(:,neigh), &
                               grid%element(next_elem+j-1)%vertex, &
                               grid%element,grid%vertex)
         grid%initial_neighbor(3,next_elem+j-1) = my_neigh
         grid%element(next_elem+j-1)%mate = grid%element(my_neigh)%gid
         grid%initial_neighbor(3,my_neigh) = next_elem+j-1
         grid%element(my_neigh)%mate = grid%element(next_elem+j-1)%gid
      end do

      next_vert = next_vert + 1
      next_elem = next_elem + 2
      next_gid = next_gid + 2

! mate is another triangle, bisect pair of triangles

   else

      my_mate = td%tri_neigh(mate(tri),tri)
      if (td%tri_neigh(mate(my_mate),my_mate) /= tri) then
         call fatal("mates are not symmetric in refine_start")
         stop
      endif

      peak = mate(tri)
      old1 = 1
      old2 = 2
      if (peak == 1) old1 = 3
      if (peak == 2) old2 = 3

      do i=1,size(vert_edges,dim=1)
         refedge = vert_edges(i,td%tri_vert(old1,tri))
         if (refedge == -1) exit
         if (td%edge_vert(1,refedge) == td%tri_vert(old2,tri) .or. &
             td%edge_vert(2,refedge) == td%tri_vert(old2,tri)) exit
      end do
      if (refedge == -1 .or. i > size(vert_edges,dim=1)) then
         call fatal("failed to find edge")
         stop
      endif

      peakm = mate(my_mate)
      old1m = 1 ! temporary for finding edge; will set after edge is determined
      old2m = 2
      if (peakm == 1) old1m = 3
      if (peakm == 2) old2m = 3

      do i=1,size(vert_edges,dim=1)
         refedgem = vert_edges(i,td%tri_vert(old1m,my_mate))
         if (refedgem == -1) exit
         if (td%edge_vert(1,refedgem) == td%tri_vert(old2m,my_mate) .or. &
             td%edge_vert(2,refedgem) == td%tri_vert(old2m,my_mate)) exit
      end do
      if (refedgem == -1 .or. i > size(vert_edges,dim=1)) then
         call fatal("failed to find edge")
         stop
      endif

      old1m = -1
      old2m = -1
      do j=1,3
         if (td%edge_bmark(refedge) < 0 .and. &
             td%vert_master(td%tri_vert(old1,tri)) /= NO_MATE) then
            if (td%tri_vert(j,my_mate) == td%vert_master(td%tri_vert(old1,tri))) old1m = j
         elseif (td%edge_bmark(refedgem) < 0 .and. &
                 td%vert_master(td%tri_vert(j,my_mate)) /= NO_MATE) then
            if (td%vert_master(td%tri_vert(j,my_mate)) == td%tri_vert(old1,tri)) old1m = j
         else
            if (td%tri_vert(j,my_mate) == td%tri_vert(old1,tri)) old1m = j
         endif
         if (td%edge_bmark(refedge) < 0 .and. &
             td%vert_master(td%tri_vert(old2,tri)) /= NO_MATE) then
            if (td%tri_vert(j,my_mate) == td%vert_master(td%tri_vert(old2,tri))) old2m = j
         elseif (td%edge_bmark(refedgem) < 0 .and. &
                 td%vert_master(td%tri_vert(j,my_mate)) /= NO_MATE) then
            if (td%vert_master(td%tri_vert(j,my_mate)) == td%tri_vert(old2,tri)) old2m = j
         else
            if (td%tri_vert(j,my_mate) == td%tri_vert(old2,tri)) old2m = j
         endif
      end do
      if (old1m == -1 .or. old2m == -1) then
         call fatal("didn't find matching vertices in mate in refine_start")
         stop
      endif

      call point_on_edge(grid, &
                         td%vert_coord(td%tri_vert(old1,tri))%x, &
                         td%vert_coord(td%tri_vert(old1,tri))%y, &
                         td%vert_bmark(td%tri_vert(old1,tri)), &
                         td%vert_bparam(td%tri_vert(old1,tri)), &
                         td%vert_coord(td%tri_vert(old2,tri))%x, &
                         td%vert_coord(td%tri_vert(old2,tri))%y, &
                         td%vert_bmark(td%tri_vert(old2,tri)), &
                         td%vert_bparam(td%tri_vert(old2,tri)), &
                         td%vert_coord(td%tri_vert(peak,tri))%x, &
                         td%vert_coord(td%tri_vert(peak,tri))%y, &
                         td%edge_bmark(refedge), &
                         0.5_my_real, &
                         grid%vertex(next_vert)%coord%x, &
                         grid%vertex(next_vert)%coord%y, &
                         grid%vertex(next_vert)%bparam)
      grid%vertex(next_vert)%bmark = td%edge_bmark(refedge)
      grid%vertex(next_vert)%assoc_elem = NO_MATE

      grid%element(next_elem  )%vertex(1) = td%tri_vert(peak,tri)
      grid%element(next_elem  )%vertex(2) = td%tri_vert(old1,tri)
      grid%element(next_elem  )%vertex(3) = next_vert

      grid%element(next_elem+1)%vertex(1) = td%tri_vert(peak,tri)
      grid%element(next_elem+1)%vertex(2) = td%tri_vert(old2,tri)
      grid%element(next_elem+1)%vertex(3) = next_vert

      if (td%edge_bmark(refedge) < 0 .or. td%edge_bmark(refedgem) < 0) then
         next_vert = next_vert + 1
         grid%nvert = grid%nvert + 1
         call point_on_edge(grid, &
                            td%vert_coord(td%tri_vert(old1m,my_mate))%x, &
                            td%vert_coord(td%tri_vert(old1m,my_mate))%y, &
                            td%vert_bmark(td%tri_vert(old1m,my_mate)), &
                            td%vert_bparam(td%tri_vert(old1m,my_mate)), &
                            td%vert_coord(td%tri_vert(old2m,my_mate))%x, &
                            td%vert_coord(td%tri_vert(old2m,my_mate))%y, &
                            td%vert_bmark(td%tri_vert(old2m,my_mate)), &
                            td%vert_bparam(td%tri_vert(old2m,my_mate)), &
                            td%vert_coord(td%tri_vert(peakm,my_mate))%x, &
                            td%vert_coord(td%tri_vert(peakm,my_mate))%y, &
                            td%edge_bmark(refedgem), &
                            0.5_my_real, &
                            grid%vertex(next_vert)%coord%x, &
                            grid%vertex(next_vert)%coord%y, &
                            grid%vertex(next_vert)%bparam)
         grid%vertex(next_vert)%bmark = td%edge_bmark(refedgem)
         grid%vertex(next_vert)%assoc_elem = NO_MATE
         if (td%edge_bmark(refedge) < 0) then
            grid%vertex(next_vert-1)%assoc_elem = next_vert
         elseif (td%edge_bmark(refedgem) < 0) then
            grid%vertex(next_vert)%assoc_elem = next_vert-1
         endif
      endif

      grid%element(next_elem+2)%vertex(1) = td%tri_vert(peakm,my_mate)
      grid%element(next_elem+2)%vertex(2) = td%tri_vert(old1m,my_mate)
      grid%element(next_elem+2)%vertex(3) = next_vert

      grid%element(next_elem+3)%vertex(1) = td%tri_vert(peakm,my_mate)
      grid%element(next_elem+3)%vertex(2) = td%tri_vert(old2m,my_mate)
      grid%element(next_elem+3)%vertex(3) = next_vert

      grid%element(next_elem  )%gid = next_gid
      grid%element(next_elem+1)%gid = next_gid+1
      grid%element(next_elem+2)%gid = next_gid+2
      grid%element(next_elem+3)%gid = next_gid+3

      refined_to(1,tri) = next_elem
      refined_to(2,tri) = next_elem+1
      refined_to(3,tri) = -1
      refined_to(1,my_mate) = next_elem+2
      refined_to(2,my_mate) = next_elem+3
      refined_to(3,my_mate) = -1

      do j=0,3
         elemedge_bmark(2,next_elem+j) = 0
         do i=1,size(vert_edges,dim=1)
            edge = vert_edges(i,grid%element(next_elem+j)%vertex(1))
            if (edge == -1) exit
            if (td%edge_vert(1,edge) == grid%element(next_elem+j)%vertex(2) .or. &
                td%edge_vert(2,edge) == grid%element(next_elem+j)%vertex(2)) exit
         end do
         if (edge == -1 .or. i > size(vert_edges,dim=1)) then
            call fatal("failed to find edge")
            stop
         endif
         elemedge_bmark(3,next_elem+j) = td%edge_bmark(edge)
      end do
      elemedge_bmark(1,next_elem  ) = td%edge_bmark(refedge)
      elemedge_bmark(1,next_elem+1) = td%edge_bmark(refedge)
      elemedge_bmark(1,next_elem+2) = td%edge_bmark(refedgem)
      elemedge_bmark(1,next_elem+3) = td%edge_bmark(refedgem)

      grid%initial_neighbor(1,next_elem  ) = next_elem+2
      grid%initial_neighbor(2,next_elem  ) = next_elem+1
      grid%initial_neighbor(3,next_elem  ) = -1

      grid%initial_neighbor(1,next_elem+1) = next_elem+3
      grid%initial_neighbor(2,next_elem+1) = next_elem
      grid%initial_neighbor(3,next_elem+1) = -1

      grid%initial_neighbor(1,next_elem+2) = next_elem
      grid%initial_neighbor(2,next_elem+2) = next_elem+3
      grid%initial_neighbor(3,next_elem+2) = -1

      grid%initial_neighbor(1,next_elem+3) = next_elem+1
      grid%initial_neighbor(2,next_elem+3) = next_elem+2
      grid%initial_neighbor(3,next_elem+3) = -1

      do j=1,4
         select case(j)
         case(1)
            neigh = td%tri_neigh(old2,tri)
         case(2)
            neigh = td%tri_neigh(old1,tri)
         case(3)
            neigh = td%tri_neigh(old2m,my_mate)
         case(4)
            neigh = td%tri_neigh(old1m,my_mate)
         end select

         if (neigh == -1) then
            grid%initial_neighbor(3,next_elem+j-1) = BOUNDARY
            grid%element(next_elem+j-1)%mate = BOUNDARY
            cycle
         endif

         if (refined_to(1,neigh) == -1) cycle ! wait until neighbor is refined

         my_neigh = find_neigh(refined_to(:,neigh), &
                               grid%element(next_elem+j-1)%vertex, &
                               grid%element,grid%vertex)
         grid%initial_neighbor(3,next_elem+j-1) = my_neigh
         grid%element(next_elem+j-1)%mate = grid%element(my_neigh)%gid
         grid%initial_neighbor(3,my_neigh) = next_elem+j-1
         grid%element(my_neigh)%mate = grid%element(next_elem+j-1)%gid
      end do

      next_vert = next_vert + 1
      next_elem = next_elem + 4
      next_gid = next_gid + 4

   endif ! no mate, boundary or paired

end do

end subroutine refine_start

!        ----------
function find_neigh(search_in,search_for,elements,vertices)
!        ----------

!----------------------------------------------------
! This routine looks through the elements indexed by search_in to find one with
! the first two vertices in search_for
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

integer, intent(in) :: search_in(3),search_for(:)
type(element_t), intent(in) :: elements(:)
type(vertex_t), intent(in) :: vertices(:)
integer :: find_neigh
!----------------------------------------------------
! Local variables:

integer :: j
!----------------------------------------------------
! Begin executable code

do j=1,3
   if (search_in(j) == -1) cycle
   if ((search_for(1) == elements(search_in(j))%vertex(1) .or. &
        search_for(1) == elements(search_in(j))%vertex(2) .or. &
        search_for(1) == elements(search_in(j))%vertex(3)) .and. &
       (search_for(2) == elements(search_in(j))%vertex(1) .or. &
        search_for(2) == elements(search_in(j))%vertex(2) .or. &
        search_for(2) == elements(search_in(j))%vertex(3))) then
      find_neigh = search_in(j)
      return
   endif
   if ((search_for(1) == vertices(elements(search_in(j))%vertex(1))%assoc_elem .or. &
        search_for(1) == vertices(elements(search_in(j))%vertex(2))%assoc_elem .or. &
        search_for(1) == vertices(elements(search_in(j))%vertex(3))%assoc_elem) .and. &
       (search_for(2) == vertices(elements(search_in(j))%vertex(1))%assoc_elem .or. &
        search_for(2) == vertices(elements(search_in(j))%vertex(2))%assoc_elem .or. &
        search_for(2) == vertices(elements(search_in(j))%vertex(3))%assoc_elem)) then
      find_neigh = search_in(j)
      return
   endif
   if ((vertices(search_for(1))%assoc_elem == elements(search_in(j))%vertex(1) .or. &
        vertices(search_for(1))%assoc_elem == elements(search_in(j))%vertex(2) .or. &
        vertices(search_for(1))%assoc_elem == elements(search_in(j))%vertex(3)) .and. &
       (vertices(search_for(2))%assoc_elem == elements(search_in(j))%vertex(1) .or. &
        vertices(search_for(2))%assoc_elem == elements(search_in(j))%vertex(2) .or. &
        vertices(search_for(2))%assoc_elem == elements(search_in(j))%vertex(3))) then
      find_neigh = search_in(j)
      return
   endif
end do

call fatal("didn't find neighbor that shares two vertices in find_neigh")
stop

end function find_neigh

!          -----------
subroutine smooth_grid(grid,procs)
!          -----------

!----------------------------------------------------
! This routine moves non-boundary vertices to smooth the triangle shapes
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

type(grid_type), intent(inout) :: grid
type(proc_info), intent(in) :: procs
!----------------------------------------------------
! Local variables:

integer, allocatable :: neigh_vert(:,:)
integer :: astat, elem, i, j, k, vert, vert2
real(my_real) :: x,y

!----------------------------------------------------
! Begin executable code

if (my_proc(procs) == MASTER) return

! For each vertex, construct a list of surrounding vertices
! Surely there won't be 32 neighbors

allocate(neigh_vert(32,grid%nvert),stat=astat)
if (astat /= 0) then
   call fatal("allocation failed for neigh_vert in smooth_grid")
   stop
endif
neigh_vert = -1

elem = grid%head_level_elem(1)
do while (elem /= END_OF_LIST)
   do vert = 1,3
      do vert2 = 1,3
         if (vert == vert2) cycle
         do i=1,32
            if (neigh_vert(i,grid%element(elem)%vertex(vert)) == -1) exit
            if (neigh_vert(i,grid%element(elem)%vertex(vert)) == &
                grid%element(elem)%vertex(vert2)) exit
         end do
         if (i==32) then
            call fatal("more than 32 neighbors in initial grid")
            stop
         endif
         if (neigh_vert(i,grid%element(elem)%vertex(vert)) == -1) then
            neigh_vert(i,grid%element(elem)%vertex(vert)) = &
               grid%element(elem)%vertex(vert2)
         endif
      end do
   end do
   elem = grid%element(elem)%next
end do

! Simple Laplacian smoothing.  Each interior vertex gets moved to the
! geometric center of its neighbors.

do k=1,10 ! do ten iterations
   do i=1,grid%nvert
      if (grid%vertex_type(i,1) /= INTERIOR) cycle
      x = 0.0_my_real
      y = 0.0_my_real
      do j=1,32
         if (neigh_vert(j,i) == -1) exit
         x = x + grid%vertex(neigh_vert(j,i))%coord%x
         y = y + grid%vertex(neigh_vert(j,i))%coord%y
      end do
      grid%vertex(i)%coord = point(x/(j-1),y/(j-1))
   end do
end do

end subroutine smooth_grid

!          ---------
subroutine init_path(grid)
!          ---------

!----------------------------------------------------
! This routine creates a path through the elements of the initial grid,
! along with in- and out- vertices, using a Sierpinski space filling curve.
! It is possible for the path to have discontinuities.
!
! This routine sets grid%head_level_elem(1) and, for each element of the
! initial grid, element%next, element%previous, element%in and element%out.
! It assumes the grid%nelem elements are in the first grid%nelem entries
! of grid%element, 
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

type(grid_type), intent(inout) :: grid
!----------------------------------------------------
! Local variables:

real(my_real) :: xcent, ycent, sfccoord(grid%nelem)
real(my_real) :: xmin, xmax, ymin, ymax
integer :: iperm(grid%nelem)
integer :: i, elem, prev, prevprev, jerr
!----------------------------------------------------
! Begin executable code

! For each element, determine the SFC mapping from its center to 1D

xmin = grid%boundbox_min%x
xmax = grid%boundbox_max%x
ymin = grid%boundbox_min%y
ymax = grid%boundbox_max%y

do elem=1,grid%nelem
   xcent = 0.0_my_real
   ycent = 0.0_my_real
   do i=1,VERTICES_PER_ELEMENT
      xcent = xcent + grid%vertex(grid%element(elem)%vertex(i))%coord%x
      ycent = ycent + grid%vertex(grid%element(elem)%vertex(i))%coord%y
   end do
   xcent = xcent/3
   ycent = ycent/3
   xcent = (xcent-xmin)/(xmax-xmin)
   ycent = (ycent-ymin)/(ymax-ymin)
   sfccoord(elem) = invsierpinski2d(xcent,ycent)
end do

! Sort the SFC coordinates to get the order of the elements

call sort(sfccoord,grid%nelem,iperm,1,jerr)

! Pass through the elements in order setting previous/next and looking
! for in/out vertices

elem = iperm(1)
grid%head_level_elem(1) = elem
grid%element(elem)%previous = END_OF_LIST
grid%element(elem)%in = grid%element(elem)%vertex(1)
prev = elem

do i=2,grid%nelem
   elem = iperm(i)
   grid%element(prev)%next = elem
   grid%element(elem)%previous = prev
   if (i == 2) then
      prevprev = -1
   else
      prevprev = iperm(i-2)
   endif
   call find_inout(elem,prev,prevprev,grid)
   prev = elem
end do

grid%element(elem)%next = END_OF_LIST
if (grid%element(elem)%in == grid%element(elem)%vertex(1)) then
   grid%element(elem)%out = grid%element(elem)%vertex(2)
else
   grid%element(elem)%out = grid%element(elem)%vertex(1)
endif

end subroutine init_path

!          ----------
subroutine find_inout(elem,prev,prevprev,grid)
!          ----------

!----------------------------------------------------
! This routine finds and sets an in-vertex for eleme and out-vertex for prev.
! Usually they will be the same vertex, but if necessary they will be different
! which will cause the Hamiltonian path to be disconnected.  If necessary and
! possible, this routine will change the in-vertex of prev and out-vertex
! of prevprev to make in and out be the same.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

integer, intent(in) :: elem, prev, prevprev
type(grid_type), intent(inout) :: grid
!----------------------------------------------------
! Local variables:

integer :: i, j
logical :: looking, shared
!----------------------------------------------------
! Begin executable code

! First look for a shared vertex of elem and prev that is not the
! in-vertex of prev

looking = .true.
do i=1,VERTICES_PER_ELEMENT
   do j=1,VERTICES_PER_ELEMENT
      if (grid%element(elem)%vertex(i) == grid%element(prev)%vertex(j) .and. &
          grid%element(prev)%vertex(j) /= grid%element(prev)%in) then
         grid%element(prev)%out = grid%element(prev)%vertex(j)
         grid%element(elem)%in  = grid%element(elem)%vertex(i)
         looking = .false.
         exit
      endif
   end do
   if (.not. looking) exit
end do

! If that failed then the in-vertex of prev must be shared, or else there
! are no shared vertices between elem and prev

if (looking) then
   shared = .false.
   do i=1,VERTICES_PER_ELEMENT
      if (grid%element(elem)%vertex(i) == grid%element(prev)%in) then
         shared = .true.
         exit
      endif
   end do

! If the in-vertex of prev is not shared, then prev and elem are not adjacent,
! so pick any vertices for the in and out

   if (.not. shared) then
      grid%element(elem)%in = grid%element(elem)%vertex(1)
      if (grid%element(prev)%in == grid%element(prev)%vertex(1)) then
         grid%element(prev)%out = grid%element(prev)%vertex(2)
      else
         grid%element(prev)%out = grid%element(prev)%vertex(1)
      endif
      looking = .false.
   endif
endif

! If the in-vertex of prev is shared, then it must be the only shared vertex
! between elem and prev (otherwise the first approach would have worked).
! Try to change the in-vertex of prev and use it as the out-vertex of prev
! and in-vertex of elem.

! First, if prev is the beginning of the path then set in-vertex to be
! any other vertex

if (looking) then
   if (prevprev == -1) then
      grid%element(elem)%in = grid%element(prev)%in
      grid%element(prev)%out = grid%element(prev)%in
      if (grid%element(prev)%in == grid%element(prev)%vertex(1)) then
         grid%element(prev)%in = grid%element(prev)%vertex(2)
      else
         grid%element(prev)%in = grid%element(prev)%vertex(1)
      endif
      looking = .false.
   endif
endif

! Second, if prev and prevprev are not adjacent or contain a broken link,
! i.e., prevprev%out is not prev%in, then change the in-vertex of prev to
! any other vertex

if (looking) then
   if (grid%element(prev)%in /= grid%element(prevprev)%out) then
      grid%element(elem)%in = grid%element(prev)%in
      grid%element(prev)%out = grid%element(prev)%in
      if (grid%element(prev)%in == grid%element(prev)%vertex(1)) then
         grid%element(prev)%in = grid%element(prev)%vertex(2)
      else
         grid%element(prev)%in = grid%element(prev)%vertex(1)
      endif
      looking = .false.
   endif
endif

! Third and final, look for a shared vertex between prev and prevprev that
! is not the in-vertex of either prev or prevprev and use that as the new
! out-vertex of prevprev and in-vertex of prev.

if (looking) then
   do i=1,VERTICES_PER_ELEMENT
      if (grid%element(prev)%in /= grid%element(prev)%vertex(i)) then
         do j=1,VERTICES_PER_ELEMENT
            if (grid%element(prevprev)%vertex(j)==grid%element(prev)%vertex(i) &
         .and. grid%element(prevprev)%vertex(j)/=grid%element(prevprev)%in) then
               grid%element(elem)%in = grid%element(prev)%in
               grid%element(prev)%out = grid%element(prev)%in
               grid%element(prev)%in = grid%element(prev)%vertex(i)
               grid%element(prevprev)%out = grid%element(prev)%vertex(i)
               looking = .false.
               exit
            endif
         end do
      endif
      if (.not. looking) exit
   end do
endif

! If that failed, give up and put in a broken link by using the in-vertex
! of prev (the only shared vertex between elem and prev) as the in-vertex
! of elem and any other vertex of prev as the out-vertex of prev.

if (looking) then
   grid%element(elem)%in = grid%element(prev)%in
   if (grid%element(prev)%in == grid%element(prev)%vertex(1)) then
      grid%element(prev)%out = grid%element(prev)%vertex(2)
   else
      grid%element(prev)%out = grid%element(prev)%vertex(1)
   endif
endif

end subroutine find_inout

!        ---------------
function invsierpinski2d(x,y)
!        ---------------

!----------------------------------------------------
! This routine returns the Sierpinski key in [0,1] for the coordinates
! (x,y) in [0,1]X[0,1]
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

real(my_real), intent(in) :: x,y
real(my_real) :: invsierpinski2d
!----------------------------------------------------
! Local variables:

!----------------------------------------------------
! Begin executable code

! sanity check for input arguments

if (x < 0 .or. x > 1 .or. y < 0 .or. y > 1) then
   ierr = PHAML_INTERNAL_ERROR
   call fatal("Input for Sierpinski out of range.")
   stop
endif

! Begin recursion that computes key

invsierpinski2d = sier2d(x, y, 0, 0, 0.5_my_real, 0.5_my_real, 0.0_my_real, &
                         0.0_my_real)

end function invsierpinski2d

!                  ------
recursive function sier2d(x, y, state, level, addf, addp, peakx, peaky) result(res)
!                  ------

!----------------------------------------------------
! This routine recursively computes the Sierpinski mapping from the unit square
! to the unit interval.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

real(my_real), intent(in) :: x, y, addf, addp, peakx, peaky
integer, intent(in) :: state, level
real(my_real) :: res
!----------------------------------------------------
! Local variables:

integer, parameter :: MAXLEV = 24
!----------------------------------------------------
! Begin executable code

if (level >= MAXLEV) then
   res = 0.0_my_real
   return
endif

select case(state)

case(0)
   if (y > x) then
      res = sier2d(x,y,1,level+1,addf/2,addp,0.0_my_real,1.0_my_real)
   else
      res = sier2d(x,y,2,level+1,addf/2,addp,1.0_my_real,0.0_my_real) + addf
   endif

case(1)
   if ( y-peaky < -(x-peakx) ) then
      res = sier2d(x,y,5,level+1,addf/2,addp,peakx+addp,peaky-addp)
   else
      res = sier2d(x,y,6,level+1,addf/2,addp,peakx+addp,peaky-addp) + addf
   endif

case(2)
   if ( y-peaky >= -(x-peakx) ) then
      res = sier2d(x,y,7,level+1,addf/2,addp,peakx-addp,peaky+addp)
   else
      res = sier2d(x,y,8,level+1,addf/2,addp,peakx-addp,peaky+addp) + addf
   endif

case(3)
   if ( y-peaky <= x-peakx ) then
      res = sier2d(x,y,8,level+1,addf/2,addp,peakx+addp,peaky+addp)
   else
      res = sier2d(x,y,5,level+1,addf/2,addp,peakx+addp,peaky+addp) + addf
   endif

case(4)
   if ( y-peaky > x-peakx ) then
      res = sier2d(x,y,6,level+1,addf/2,addp,peakx-addp,peaky-addp)
   else
      res = sier2d(x,y,7,level+1,addf/2,addp,peakx-addp,peaky-addp) + addf
   endif

case(5)
   if ( y < peaky ) then
      res = sier2d(x,y,1,level+1,addf/2,addp/2,peakx-addp,peaky)
   else
      res = sier2d(x,y,3,level+1,addf/2,addp/2,peakx-addp,peaky) + addf
   endif

case(6)
   if ( x < peakx ) then
      res = sier2d(x,y,4,level+1,addf/2,addp/2,peakx,peaky+addp)
   else
      res = sier2d(x,y,1,level+1,addf/2,addp/2,peakx,peaky+addp) + addf
   endif

case(7)
   if ( y >= peaky ) then
      res = sier2d(x,y,2,level+1,addf/2,addp/2,peakx+addp,peaky)
   else
      res = sier2d(x,y,4,level+1,addf/2,addp/2,peakx+addp,peaky) + addf
   endif

case(8)
   if ( x >= peakx ) then
      res = sier2d(x,y,3,level+1,addf/2,addp/2,peakx,peaky-addp)
   else
      res = sier2d(x,y,2,level+1,addf/2,addp/2,peakx,peaky-addp) + addf
   endif

end select

end function sier2d

end module grid_init_mod
